{
  "version": 3,
  "sources": ["src/use-controlled.ts", "src/use-id.ts", "../utils/src/input-utils.ts", "../utils/src/nanoid/index.ts", "../utils/src/filterTypes.ts", "src/useEffectSkipFirst.ts", "src/use-fork-ref.ts", "src/use-resize-observer.ts"],
  "sourcesContent": ["import { Dispatch, SetStateAction, useCallback, useRef, useState } from 'react';\n\nexport interface UseControlledProps<T = unknown> {\n  controlled: T | undefined;\n  default: T | undefined;\n}\n\nexport function useControlled<T = unknown>({\n  controlled,\n  default: defaultProp\n}: UseControlledProps<T>): [T | undefined, Dispatch<SetStateAction<T>>, boolean] {\n  const { current: isControlled } = useRef(controlled !== undefined);\n  const [valueState, setValue] = useState(defaultProp);\n  const value = isControlled ? controlled : valueState;\n  const setValueIfUncontrolled = useCallback(\n    (newValue) => {\n      if (!isControlled) {\n        setValue(newValue);\n      }\n    },\n    [isControlled]\n  );\n\n  return [value, setValueIfUncontrolled, isControlled];\n}\n", "import { useMemo } from 'react';\nimport { uuid } from '@vuu-ui/utils';\n\nexport const useId = (idProp?: string) => {\n  const id = useMemo(() => {\n    return idProp || uuid(5);\n  }, [idProp]);\n  return id;\n};\n\nexport const getUniqueId = () => `hw-${Math.round(Math.random() * 1e5)}`;\n", "const actionKeys = {\n  Enter: 'Enter',\n  Delete: 'Delete'\n};\n\nconst navigationKeys = {\n  Home: 'Home',\n  End: 'End',\n  ArrowRight: 'ArrowRight',\n  ArrowLeft: 'ArrowLeft',\n  ArrowDown: 'ArrowDown',\n  ArrowUp: 'ArrowUp',\n  Tab: 'Tab'\n};\nconst functionKeys = {\n  F1: 'F1',\n  F2: 'F2',\n  F3: 'F3',\n  F4: 'F4',\n  F5: 'F5',\n  F6: 'F6',\n  F7: 'F7',\n  F8: 'F8',\n  F9: 'F9',\n  F10: 'F10',\n  F11: 'F11',\n  F12: 'F12'\n};\n\nconst specialKeys = {\n  ...actionKeys,\n  ...navigationKeys,\n  ...functionKeys\n};\ntype specialKey = keyof typeof specialKeys;\n\nconst isSpecialKey = (key: string): key is specialKey => key in specialKeys;\n\nexport const isCharacterKey = (evt: KeyboardEvent) => {\n  if (isSpecialKey(evt.key)) {\n    return false;\n  }\n  if (typeof evt.which === 'number' && evt.which > 0) {\n    return !evt.ctrlKey && !evt.metaKey && !evt.altKey && evt.which !== 8;\n  }\n};\n\nexport const isQuoteKey = (evt: KeyboardEvent) => {\n  return evt.key === '\"' || evt.key === \"'\";\n};\n", "// This is the index.browser.js file from nanoid\n// couldn't get original code to work as npm import without crypro warnings -\n// seemed to be picking up node version, not browser version\n\nexport const uuid = (size: number = 21): string => {\n  let id: string = '';\n  let bytes = crypto.getRandomValues(new Uint8Array(size));\n\n  // A compact alternative for `for (var i = 0; i < step; i++)`.\n  while (size--) {\n    // It is incorrect to use bytes exceeding the alphabet size.\n    // The following mask reduces the random byte in the 0-255 value\n    // range to the 0-63 value range. Therefore, adding hacks, such\n    // as empty string fallback or magic numbers, is unneccessary because\n    // the bitmask trims bytes down to the alphabet size.\n    let byte = bytes[size] & 63;\n    if (byte < 36) {\n      // `0-9a-z`\n      id += byte.toString(36);\n    } else if (byte < 62) {\n      // `A-Z`\n      id += (byte - 26).toString(36).toUpperCase();\n    } else if (byte < 63) {\n      id += '_';\n    } else {\n      id += '-';\n    }\n  }\n  return id;\n};\n", "export type FilterClauseOp = '=' | '>' | '>=' | 'in' | '<=' | '<' | 'starts' | 'ends';\nexport type FilterCombinatorOp = 'and' | 'or';\nexport type FilterOp = FilterClauseOp | FilterCombinatorOp;\n\nconst singleValueFilterOps = new Set(['=', '>', '>=', '<', '<=', 'starts', 'ends']);\n\nexport interface SingleValueFilterClause {\n  op: '=' | '>' | '>=' | '<' | '<=' | 'starts' | 'ends';\n  column: string;\n  value: any;\n}\nexport interface MultiValueFilterClause {\n  op: 'in';\n  column: string;\n  values: any[];\n}\n\nexport type FilterClause = SingleValueFilterClause | MultiValueFilterClause;\n\nexport interface MultiClauseFilter {\n  column?: never;\n  op: 'and' | 'or';\n  filters: Filter[];\n}\n\nexport interface AndFilter extends MultiClauseFilter {\n  op: 'and';\n}\nexport interface OrFilter extends MultiClauseFilter {\n  op: 'or';\n}\n\nexport type Filter = FilterClause | MultiClauseFilter;\n\nexport const isMultiClauseFilter = (f: Filter): f is MultiClauseFilter =>\n  Array.isArray((f as MultiClauseFilter).filters);\n\nexport const isSingleValueFilter = (f: Filter): f is SingleValueFilterClause =>\n  singleValueFilterOps.has(f.op);\n\nexport const isFilterClause = (f: Filter): f is SingleValueFilterClause | MultiValueFilterClause =>\n  isSingleValueFilter(f) || isMultiClauseFilter(f);\n\nexport const isMultiValueFilter = (f: Filter): f is MultiValueFilterClause => f.op === 'in';\n\nexport const isInFilter = (f: Filter): f is MultiValueFilterClause => f.op === 'in';\nexport const isAndFilter = (f: Filter): f is AndFilter => f.op === 'and';\nexport const isOrFilter = (f: Filter): f is OrFilter => f.op === 'or';\n", "import { useEffect, useRef } from 'react';\n\nexport const useEffectSkipFirst = (func: (...args: unknown[]) => void, deps: unknown[]) => {\n  const goodToGo = useRef(false);\n  useEffect(() => {\n    if (goodToGo.current) {\n      func();\n    } else {\n      goodToGo.current = true;\n    }\n  }, deps);\n};\n", "import { MutableRefObject, Ref, useMemo } from 'react';\n\ntype RefValue<T> = MutableRefObject<T | null> | ((instance: T | null) => void) | null | undefined;\n\nfunction setRef<T>(ref: RefValue<T>, value: T | null) {\n  if (typeof ref === 'function') {\n    ref(value);\n  } else if (ref) {\n    ref.current = value;\n  }\n}\n\nexport function useForkRef<T>(\n  refA: Ref<T> | null | undefined,\n  refB: Ref<T> | null | undefined\n): Ref<T> | null {\n  /**\n   * This will create a new function if the ref props change and are defined.\n   * This means react will call the old forkRef with `null` and the new forkRef\n   * with the ref. Cleanup naturally emerges from this behavior\n   */\n  return useMemo(() => {\n    if (refA == null && refB == null) {\n      return null;\n    }\n    return (refValue) => {\n      setRef(refA, refValue);\n      setRef(refB, refValue);\n    };\n  }, [refA, refB]);\n}\n", "import { RefObject, useCallback, useEffect, useRef } from 'react';\n\nexport const WidthHeight = ['height', 'width'];\nexport const WidthOnly = ['width'];\n\nexport type measurements<T = string | number> = {\n  height?: T;\n  scrollHeight?: T;\n  scrollWidth?: T;\n  width?: T;\n};\ntype measuredDimension = keyof measurements<number>;\n\nexport type ResizeHandler = (measurements: measurements<number>) => void;\n\ntype observedDetails = {\n  onResize?: ResizeHandler;\n  measurements: measurements<number>;\n};\nconst observedMap = new Map<HTMLElement, observedDetails>();\n\nconst getTargetSize = (\n  element: HTMLElement,\n  contentRect: { height: number; width: number },\n  dimension: measuredDimension\n): number => {\n  switch (dimension) {\n    case 'height':\n      return contentRect.height;\n    case 'scrollHeight':\n      return Math.ceil(element.scrollHeight);\n    case 'scrollWidth':\n      return Math.ceil(element.scrollWidth);\n    case 'width':\n      return contentRect.width;\n    default:\n      return 0;\n  }\n};\n\nconst isScrollAttribute = {\n  scrollHeight: true,\n  scrollWidth: true\n};\n\n// TODO should we make this create-on-demand\nconst resizeObserver = new ResizeObserver((entries: ResizeObserverEntry[]) => {\n  for (const entry of entries) {\n    const { target, borderBoxSize } = entry;\n    const observedTarget = observedMap.get(target as HTMLElement);\n    if (observedTarget) {\n      const [{ blockSize: height, inlineSize: width }] = borderBoxSize;\n      const rect = { height, width };\n      const { onResize, measurements } = observedTarget;\n      let sizeChanged = false;\n      for (let [dimension, size] of Object.entries(measurements)) {\n        const newSize = getTargetSize(\n          target as HTMLElement,\n          { height, width },\n          dimension as measuredDimension\n        );\n\n        if (newSize !== size) {\n          sizeChanged = true;\n          measurements[dimension as measuredDimension] = newSize;\n        }\n      }\n      if (sizeChanged) {\n        // TODO only return measured sizes\n        // const { height, width } = contentRect;\n        onResize && onResize(measurements);\n      }\n    }\n  }\n});\n\n// TODO use an optional lag (default to false) to ask to fire onResize\n// with initial size\nexport function useResizeObserver(\n  ref: RefObject<Element | HTMLElement | null>,\n  dimensions: string[],\n  onResize: ResizeHandler,\n  reportInitialSize = false\n) {\n  const dimensionsRef = useRef(dimensions);\n\n  const measure = useCallback((target: HTMLElement): measurements<number> => {\n    const rect = target.getBoundingClientRect();\n    return dimensionsRef.current.reduce((map: { [key: string]: number }, dim) => {\n      map[dim] = getTargetSize(target, rect, dim as measuredDimension);\n      return map;\n    }, {});\n  }, []);\n\n  // TODO use ref to store resizeHandler here\n  // resize handler registered with REsizeObserver will never change\n  // use ref to store user onResize callback here\n  // resizeHandler will call user callback.current\n\n  // Keep this effect separate in case user inadvertently passes different\n  // dimensions or callback instance each time - we only ever want to\n  // initiate new observation when ref changes.\n  useEffect(() => {\n    const target = ref.current as HTMLElement;\n    async function registerObserver() {\n      // Create the map entry immediately. useEffect may fire below\n      // before fonts are ready and attempt to update entry\n      observedMap.set(target, { measurements: {} as measurements<number> });\n      await document.fonts.ready;\n      const observedTarget = observedMap.get(target);\n      if (observedTarget) {\n        const measurements = measure(target);\n        observedTarget.measurements = measurements;\n        resizeObserver.observe(target);\n        if (reportInitialSize) {\n          onResize(measurements);\n        }\n      } else {\n        console.log(\n          `%cuseResizeObserver an target expected to be under observation wa snot found. This warrants investigation`,\n          'font-weight:bold; color:red;'\n        );\n      }\n    }\n\n    if (target) {\n      // TODO might we want multiple callers to attach a listener to the same element ?\n      if (observedMap.has(target)) {\n        throw Error('useResizeObserver attemping to observe same element twice');\n      }\n      // TODO set a pending entry on map\n      registerObserver();\n    }\n    return () => {\n      if (target && observedMap.has(target)) {\n        resizeObserver.unobserve(target);\n        observedMap.delete(target);\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [measure, ref]);\n\n  useEffect(() => {\n    const target = ref.current as HTMLElement;\n    const record = observedMap.get(target);\n    if (record) {\n      if (dimensionsRef.current !== dimensions) {\n        dimensionsRef.current = dimensions;\n        const measurements = measure(target);\n        record.measurements = measurements;\n      }\n      // Might not have changed, but no harm ...\n      record.onResize = onResize;\n    }\n  }, [dimensions, measure, ref, onResize]);\n}\n"],
  "mappings": "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",
  "names": []
}
