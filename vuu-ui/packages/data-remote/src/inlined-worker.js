export function InlinedWorker() {
var K=console,D={},T=Symbol("setWebsocket"),I=Symbol("connectionCallback");async function H(i,e){return x(i,e)}async function _(i){x(i.url,i[I],i)}async function x(i,e,t){let s=D[i]||(D[i]={attemptsRemaining:5,status:"disconnected"});try{e({type:"connection-status",status:"connecting"});let n=typeof t<"u",r=await Te(i);console.log(`%c\u26A1 %c${i}`,"font-size: 24px;color: green;font-weight: bold;","color:green; font-size: 14px;"),t!==void 0&&t[T](r);let a=t??new v(r,i,e),o=n?"reconnected":"connected";return e({type:"connection-status",status:o}),a.status=o,a}catch{let r=--s.attemptsRemaining>0;if(e({type:"connection-status",status:"disconnected",reason:"failed to connect",retry:r}),r)return _e(i,e,t,1e4);throw Error("Failed to establish connection")}}var _e=(i,e,t,s)=>new Promise(n=>{setTimeout(()=>{n(x(i,e,t))},s)}),Te=i=>new Promise((e,t)=>{let s=new WebSocket("ws://"+i);s.onopen=()=>e(s),s.onerror=n=>t(n)}),q=()=>{K.log("Connection cannot be closed, socket not yet opened")},G=i=>{K.log(`Message cannot be sent, socket closed: ${i.body.type}`)},ve=i=>{try{return JSON.parse(i)}catch{throw Error(`Error parsing JSON response from server ${i}`)}},v=class{[I];close=q;requiresLogin=!0;send=G;status="ready";url;constructor(e,t,s){this.url=t,this[I]=s,this[T](e)}reconnect(){_(this)}[T](e){let t=this[I];e.onmessage=r=>{let a=ve(r.data);t(a)},e.onerror=()=>{console.log(`%c\u26A1 %c${this.url}`,"font-size: 24px;color: red;font-weight: bold;","color:red; font-size: 14px;"),t({type:"connection-status",status:"disconnected",reason:"error"}),this.status!=="closed"&&(_(this),this.send=n)},e.onclose=()=>{console.log(`%c\u26A1 %c${this.url}`,"font-size: 24px;color: orange;font-weight: bold;","color:orange; font-size: 14px;"),t({type:"connection-status",status:"disconnected",reason:"close"}),this.status!=="closed"&&(_(this),this.send=n)};let s=r=>{e.send(JSON.stringify(r))},n=r=>{console.log(`queuing message ${JSON.stringify(r)} until websocket reconnected`)};this.send=s,this.close=()=>{console.log("[Connection] close websocket"),this.status="closed",e.close(),this.close=q,this.send=G}}};var $="CHANGE_VP",J="CHANGE_VP_SUCCESS",U="CHANGE_VP_RANGE",z="CHANGE_VP_RANGE_SUCCESS",Q="CLOSE_TREE_NODE",Y="CLOSE_TREE_SUCCESS";var O="CREATE_VISUAL_LINK",j="CREATE_VISUAL_LINK_SUCCESS",X="CREATE_VP",Z="CREATE_VP_SUCCESS",ee="DISABLE_VP",te="DISABLE_VP_SUCCESS";var se="ENABLE_VP",ne="ENABLE_VP_SUCCESS";var re="GET_TABLE_LIST",oe="GET_TABLE_META",ie="GET_VP_VISUAL_LINKS",ae="GET_VIEW_PORT_MENUS",ue="VIEW_PORT_MENUS_RESP";var P="VIEW_PORT_MENU_RESP";var le="HB",ce="HB_RESP",pe="LOGIN",ge="LOGIN_SUCCESS",de="OPEN_TREE_NODE",he="OPEN_TREE_SUCCESS";var fe="REMOVE_VP",Ve="REMOVE_VP_SUCCESS";var Ce="RPC_CALL",L="RPC_RESP";var Ee="SET_SELECTION",Ie="SET_SELECTION_SUCCESS",A="TABLE_META_RESP",N="TABLE_LIST_RESP",Se="VP_VISUAL_LINKS_RESP",be="TABLE_ROW";var S=class{keys;free;nextKeyValue;constructor(e){this.keys=new Map,this.free=[],this.nextKeyValue=0,this.reset(e)}next(){return this.free.length>0?this.free.pop():this.nextKeyValue++}reset({from:e,to:t}){this.keys.forEach((n,r)=>{(r<e||r>=t)&&(this.free.push(n),this.keys.delete(r))});let s=t-e;this.keys.size+this.free.length>s&&(this.free.length=s-this.keys.size);for(let n=e;n<t;n++)if(!this.keys.has(n)){let r=this.next();this.keys.set(n,r)}}keyFor(e){let t=this.keys.get(e);if(t===void 0)throw Error(`KeySet, no key found for rowIndex ${e}`);return t}};var xe={Enter:"Enter",Delete:"Delete"},Ue={Home:"Home",End:"End",ArrowRight:"ArrowRight",ArrowLeft:"ArrowLeft",ArrowDown:"ArrowDown",ArrowUp:"ArrowUp",Tab:"Tab"},Oe={F1:"F1",F2:"F2",F3:"F3",F4:"F4",F5:"F5",F6:"F6",F7:"F7",F8:"F8",F9:"F9",F10:"F10",F11:"F11",F12:"F12"},Qe={...xe,...Ue,...Oe};function F({from:i,to:e},t=0,s=Number.MAX_SAFE_INTEGER){if(t===0)return{from:i,to:Math.min(e,s)};if(i===0)return{from:i,to:Math.min(e+t,s)};{let n=e-i,r=Math.round(t/2),a=i-r<0,o=s-(e+r)<0;return a&&o?{from:0,to:s}:a?{from:0,to:n+t}:o?{from:Math.max(0,s-(n+t)),to:s}:{from:i-r,to:e+r}}}var h=class{from;to;constructor(e,t){this.from=e,this.to=t}isWithin(e){return e>=this.from&&e<this.to}overlap(e,t){return e>=this.to||t<this.from?[0,0]:[Math.max(e,this.from),Math.min(t,this.to)]}copy(){return new h(this.from,this.to)}};var b=(i,e,t,s)=>{let n=s*.25;return!i||!s||i.to-t<n?!0:i.from>0&&e-i.from<n};var y=[],m=class{bufferSize;range;internalData;rowsWithinRange;clientRange;rowCount;constructor({from:e,to:t},{from:s,to:n},r){this.bufferSize=r,this.clientRange=new h(e,t),this.range=new h(s,n),this.internalData=new Array(r),this.rowsWithinRange=0,this.rowCount=0}get hasAllRowsWithinRange(){return this.rowsWithinRange===this.clientRange.to-this.clientRange.from||this.rowCount>0&&this.rowsWithinRange===this.rowCount}setRowCount=e=>{if(e<this.internalData.length&&(this.internalData.length=e),e<this.rowCount){this.rowsWithinRange=0;let t=Math.min(e,this.clientRange.to);for(let s=this.clientRange.from;s<t;s++){let n=s-this.range.from;this.internalData[n]!==void 0&&(this.rowsWithinRange+=1)}}this.rowCount=e};setAtIndex(e,t){let s=this.isWithinClientRange(e);if(s||this.isWithinRange(e)){let n=e-this.range.from;!this.internalData[n]&&s&&(this.rowsWithinRange+=1),this.internalData[n]=t}return s}getAtIndex(e){return this.range.isWithin(e)&&this.internalData[e-this.range.from]!=null?this.internalData[e-this.range.from]:void 0}isWithinRange(e){return this.range.isWithin(e)}isWithinClientRange(e){return this.clientRange.isWithin(e)}setClientRange(e,t){let s=this.clientRange.from,n=Math.min(this.clientRange.to,this.rowCount);if(e===s&&t===n)return[!1,y,y];let r=this.clientRange.copy();this.clientRange.from=e,this.clientRange.to=t,this.rowsWithinRange=0;for(let l=e;l<t;l++){let p=l-this.range.from;this.internalData[p]&&(this.rowsWithinRange+=1)}let a=y,o=y,u=this.range.from;if(this.hasAllRowsWithinRange)if(t>r.to){let l=Math.max(e,r.to);a=this.internalData.slice(l-u,t-u)}else{let l=Math.min(r.from,t);a=this.internalData.slice(e-u,l-u)}else if(this.rowsWithinRange>0)if(t>r.to){let l=Math.max(e,r.to);o=this.internalData.slice(l-u,t-u).filter(p=>!!p)}else{let l=Math.max(r.from,t);o=this.internalData.slice(Math.max(0,e-u),l-u).filter(p=>!!p)}return[b(this.range,e,t,this.bufferSize),a,o]}setRange(e,t){let[s,n]=this.range.overlap(e,t),r=new Array(t-e+this.bufferSize);this.rowsWithinRange=0;for(let a=s;a<n;a++){let o=this.getAtIndex(a);if(o){let u=a-e;r[u]=o,this.isWithinClientRange(a)&&(this.rowsWithinRange+=1)}}this.internalData=r,this.range.from=e,this.range.to=t}getData(){let{from:e,to:t}=this.range,{from:s,to:n}=this.clientRange,r=Math.max(0,s-e),a=Math.min(t-e,t,n-e,this.rowCount??t);return this.internalData.slice(r,a)}};var Le=[],Ae=[],Ne=([i],[e])=>i-e,M=class{aggregations;bufferSize;clientRange;columns;dataWindow=void 0;disabled=!1;filter;filterSpec;groupBy;hasUpdates=!1;holdingPen=[];keys;lastTouchIdx=null;links=[];linkedParent=null;pendingLinkedParent;pendingOperations=new Map;pendingRangeRequest=null;rowCountChanged=!1;sort;clientViewportId;isTree=!1;serverViewportId;status="";suspended=!1;table;constructor({viewport:e,tablename:t,aggregations:s,columns:n,range:r,bufferSize:a=50,filter:o="",filterQuery:u="",sort:c=[],groupBy:l=[],visualLink:p}){this.clientViewportId=e,this.table=t,this.aggregations=s,this.columns=n,this.clientRange=r,this.bufferSize=a,this.sort={sortDefs:c},this.groupBy=l,this.filterSpec={filter:u},this.filter=o,this.keys=new S(r),this.pendingLinkedParent=p}get hasUpdatesToProcess(){return this.suspended?!1:this.rowCountChanged||this.hasUpdates}subscribe(){return{type:X,table:this.table,range:F(this.clientRange,this.bufferSize),aggregations:this.aggregations,columns:this.columns,sort:this.sort,groupBy:this.groupBy,filterSpec:this.filterSpec}}handleSubscribed({viewPortId:e,aggregations:t,columns:s,range:n,sort:r,groupBy:a,filterSpec:o}){return this.serverViewportId=e,this.status="subscribed",this.aggregations=t,this.columns=s,this.groupBy=a,this.filterSpec=o,this.isTree=a&&a.length>0,this.dataWindow=new m(this.clientRange,n,this.bufferSize),console.log(`%cViewport subscribed
        clientVpId: ${this.clientViewportId}
        serverVpId: ${this.serverViewportId}
        table: ${this.table}
        aggregations: ${JSON.stringify(t)}
        columns: ${s.join(",")}
        range: ${JSON.stringify(n)}
        sort: ${JSON.stringify(r)}
        groupBy: ${JSON.stringify(a)}
        filterSpec: ${JSON.stringify(o)}
        bufferSize: ${this.bufferSize}
      `,"color: blue"),{type:"subscribed",clientViewportId:this.clientViewportId,columns:s,filter:this.filter,filterSpec:this.filterSpec}}awaitOperation(e,t){this.pendingOperations.set(e,t)}completeOperation(e,...t){let{clientViewportId:s,pendingOperations:n}=this,{type:r,data:a}=n.get(e);if(n.delete(e),r===U){let[o,u]=t;this.dataWindow?.setRange(o,u),this.pendingRangeRequest=null}else{if(r==="groupBy")return this.isTree=!0,this.groupBy=a,{clientViewportId:s,type:r,groupBy:a};if(r==="groupByClear")return this.isTree=!1,this.groupBy=[],{clientViewportId:s,type:"groupBy",groupBy:null};if(r==="filter")return this.filterSpec={filter:a.filterQuery},{clientViewportId:s,type:r,...a};if(r==="aggregate")return this.aggregations=a,{clientViewportId:s,type:r,aggregations:a};if(r==="sort")return this.sort={sortDefs:a},{clientViewportId:s,type:r,sort:a};if(r!=="selection"){if(r==="disable")return this.disabled=!0,{type:"disabled",clientViewportId:s};if(r==="enable")return this.disabled=!1,{type:"enabled",clientViewportId:s};if(r===O){let[o,u,c]=t;return this.linkedParent={colName:o,parentViewportId:u,parentColName:c},this.pendingLinkedParent=null,{type:"visual-link-created",clientViewportId:s,colName:o,parentViewportId:u,parentColName:c}}}}}rangeRequest(e,t){let s=U;if(this.dataWindow){let[n,r,a]=this.dataWindow.setClientRange(t.from,t.to),o=n&&b(this.pendingRangeRequest,t.from,t.to,this.bufferSize)?{type:s,viewPortId:this.serverViewportId,...F(t,this.bufferSize,this.dataWindow.rowCount)}:null;o&&(this.awaitOperation(e,{type:s}),this.pendingRangeRequest=o),this.keys.reset(this.dataWindow.clientRange);let u=([l])=>l<t.from||l>=t.to;this.holdingPen.some(u)&&(this.holdingPen=this.holdingPen.filter(([l])=>l>=t.from&&l<t.to));let c=this.isTree?B(this.groupBy,this.columns):k;return a.length&&a.forEach(l=>{this.holdingPen.push(c(l,this.keys))}),r.length?[o,r.map(l=>c(l,this.keys))]:[o]}else return[null]}setLinks(e){return this.links=e,[{type:"VP_VISUAL_LINKS_RESP",links:e,clientViewportId:this.clientViewportId},this.pendingLinkedParent]}setMenu(e){return{type:"VIEW_PORT_MENUS_RESP",menu:e,clientViewportId:this.clientViewportId}}createLink(e,t,s,n){let r={type:O,parentVpId:s,childVpId:this.serverViewportId,parentColumnName:n,childColumnName:t};return this.awaitOperation(e,r),r}suspend(){this.suspended=!0}resume(){return this.suspended=!1,this.currentData()}currentData(){let e=[];if(this.dataWindow){let t=this.dataWindow.getData(),{keys:s}=this,n=this.isTree?B(this.groupBy,this.columns):k;for(let r of t)r&&e.push(n(r,s))}return e}enable(e){return this.awaitOperation(e,{type:"enable"}),{type:se,viewPortId:this.serverViewportId}}disable(e){return this.awaitOperation(e,{type:"disable"}),{type:ee,viewPortId:this.serverViewportId}}filterRequest(e,t,s){return this.awaitOperation(e,{type:"filter",data:{filter:t,filterQuery:s}}),this.createRequest({filterSpec:{filter:s}})}aggregateRequest(e,t){return this.awaitOperation(e,{type:"aggregate",data:t}),this.createRequest({aggregations:t})}sortRequest(e,t){return this.awaitOperation(e,{type:"sort",data:t}),this.createRequest({sort:{sortDefs:t}})}groupByRequest(e,t=Ae){let s=t===Le?"groupByClear":"groupBy";return this.awaitOperation(e,{type:s,data:t}),this.createRequest({groupBy:t})}selectRequest(e,t){return this.awaitOperation(e,{type:"selection",data:t}),{type:Ee,vpId:this.serverViewportId,selection:t}}handleUpdate(e,t,s){this.dataWindow&&(this.dataWindow.rowCount!==s.vpSize&&(this.dataWindow.setRowCount(s.vpSize),this.rowCountChanged=!0),e==="U"&&this.dataWindow.setAtIndex(t,s)&&(this.hasUpdates=!0))}getNewRowCount=()=>{if(this.rowCountChanged&&this.dataWindow)return this.rowCountChanged=!1,this.dataWindow.rowCount};getClientRows(e){if(this.hasUpdates&&this.dataWindow){let t=this.dataWindow.getData(),{keys:s}=this,n=this.isTree?B(this.groupBy,this.columns):k,r=this.dataWindow.hasAllRowsWithinRange?this.holdingPen.splice(0):void 0,a=r||this.holdingPen;for(let o of t)o&&o.ts>=e&&a.push(n(o,s));return this.hasUpdates=!1,r&&r.sort(Ne)}}createRequest(e){return{type:$,viewPortId:this.serverViewportId,aggregations:this.aggregations,columns:this.columns,sort:this.sort,groupBy:this.groupBy,filterSpec:this.filterSpec,...e}}},k=({rowIndex:i,rowKey:e,sel:t,data:s},n)=>[i,n.keyFor(i),!0,null,null,1,e,t].concat(s),B=(i,e)=>({rowIndex:t,rowKey:s,sel:n,data:r},a)=>{let[o,u,,c,,l,...p]=r,V=s.split("|").slice(1);return i.forEach((d,E)=>{let w=e.indexOf(d);p[w]=V[E]}),[t,a.keyFor(t),c,u,o,l,s,n].concat(p)};var me=i=>{switch(i){case"getUniqueFieldValues":return["TypeAheadRpcHandler","TYPEAHEAD"];default:return["OrderEntryRpcHandler","SIMUL"]}};var Me=i=>i.type==="connection-status",Re=i=>"viewport"in i;var we=1;var g=()=>`${we++}`,Fe=[],ke={},Be=(i,e)=>{if(i==="MENU_RPC_CALL"&&e==="selected-rows")return"VIEW_PORT_MENUS_SELECT_RPC";throw Error("No RPC command for ${msgType} / ${context}")},R=class{connection;postMessageToClient;viewports;mapClientToServerViewport;authToken="";pendingLogin;sessionId;queuedRequests=[];constructor(e,t){this.connection=e,this.postMessageToClient=t,this.viewports=new Map,this.mapClientToServerViewport=new Map}async login(e){if(e)return this.authToken=e,new Promise((t,s)=>{this.sendMessageToServer({type:pe,token:this.authToken,user:"user"},""),this.pendingLogin={resolve:t,reject:s}});this.authToken===""&&console.warn("ServerProxy login, cannot login until auth token has been obtained")}subscribe(e){if(this.mapClientToServerViewport.has(e.viewport))console.log(`ServerProxy spurious subscribe call ${e.viewport}`);else{let t=new M(e);this.viewports.set(e.viewport,t),this.sendIfReady(t.subscribe(),e.viewport,this.sessionId!=="")}}unsubscribe(e){let t=this.mapClientToServerViewport.get(e);t?this.sendMessageToServer({type:fe,viewPortId:t}):console.error(`ServerProxy: failed to unsubscribe client viewport ${e}`)}getViewportForClient(e){let t=this.mapClientToServerViewport.get(e);if(t){let s=this.viewports.get(t);if(s)return s;throw Error(`Viewport not found for client viewport ${e}`)}else throw Error(`Viewport server id not found for client viewport ${e}`)}setViewRange(e,t){let s=g(),[n,r]=e.rangeRequest(s,t.range);n&&this.sendIfReady(n,s,e.status==="subscribed"),r&&this.postMessageToClient({type:"viewport-updates",viewports:{[e.clientViewportId]:{rows:r}}})}aggregate(e,t){let s=g(),n=e.aggregateRequest(s,t.aggregations);this.sendIfReady(n,s,e.status==="subscribed")}sort(e,t){let s=g(),n=e.sortRequest(s,t.sortCriteria);this.sendIfReady(n,s,e.status==="subscribed")}groupBy(e,t){let s=g(),n=e.groupByRequest(s,t.groupBy);this.sendIfReady(n,s,e.status==="subscribed")}filter(e,t){let s=g(),{filter:n,filterQuery:r}=t,a=e.filterRequest(s,n,r);this.sendIfReady(a,s,e.status==="subscribed")}select(e,t){let s=g(),{selected:n}=t,r=e.selectRequest(s,n);this.sendIfReady(r,s,e.status==="subscribed")}disableViewport(e,t){let s=g(),n=e.disable(s);this.sendIfReady(n,s,e.status==="subscribed")}enableViewport(e,t){let s=g(),n=e.enable(s);this.sendIfReady(n,s,e.status==="subscribed")}resumeViewport(e){let t=e.resume();this.postMessageToClient({type:"viewport-updates",viewports:{[e.clientViewportId]:{rows:t}}})}openTreeNode(e,t){e.serverViewportId&&this.sendIfReady({type:de,vpId:e.serverViewportId,treeKey:t.key},g(),e.status==="subscribed")}closeTreeNode(e,t){e.serverViewportId&&this.sendIfReady({type:Q,vpId:e.serverViewportId,treeKey:t.key},g(),e.status==="subscribed")}createLink(e,t){let{parentVpId:s,parentColumnName:n,childColumnName:r}=t,a=g(),o=e.createLink(a,r,s,n);this.sendMessageToServer(o,a)}menuRpcCall(e,t){if(e.serverViewportId){let{context:s,rpcName:n}=t;this.sendMessageToServer({type:Be(t.type,s),rpcName:n,vpId:e.serverViewportId},t.requestId)}}rpcCall(e){let{method:t,requestId:s,type:n}=e,[r,a]=me(t);this.sendMessageToServer({type:n,service:r,method:t,params:e.params,namedParams:{}},s,{module:a})}handleMessageFromClient(e){if(Re(e)){let t=this.getViewportForClient(e.viewport);switch(e.type){case"setViewRange":return this.setViewRange(t,e);case"aggregate":return this.aggregate(t,e);case"sort":return this.sort(t,e);case"groupBy":return this.groupBy(t,e);case"filterQuery":return this.filter(t,e);case"select":return this.select(t,e);case"suspend":return t.suspend();case"resume":return this.resumeViewport(t);case"disable":return this.disableViewport(t,e);case"enable":return this.enableViewport(t,e);case"openTreeNode":return this.openTreeNode(t,e);case"closeTreeNode":return this.closeTreeNode(t,e);case"createLink":return this.createLink(t,e);case"MENU_RPC_CALL":return this.menuRpcCall(t,e);default:}}else{let{type:t,requestId:s}=e;switch(t){case re:return this.sendMessageToServer({type:t},s);case oe:return this.sendMessageToServer({type:t,table:e.table},s);case Ce:return this.rpcCall(e);default:}}console.log(`Vuu ServerProxy Unexpected message from client ${JSON.stringify(e)}`)}sendIfReady(e,t,s=!0,n){return s?this.sendMessageToServer(e,t,n):this.queuedRequests.push(e),s}sendMessageToServer(e,t=`${we++}`,s=ke){let{module:n="CORE",...r}=s;this.authToken&&this.connection.send({requestId:t,sessionId:this.sessionId,token:this.authToken,user:"user",module:n,body:e})}handleMessageFromServer(e){let{body:t,requestId:s,sessionId:n}=e,{viewports:r}=this;switch(t.type){case le:this.sendMessageToServer({type:ce,ts:+new Date},"NA");break;case ge:this.sessionId=n,this.pendingLogin?.resolve(n);break;case Z:{let o=r.get(s);if(o){let{viewPortId:u}=t;s!==u&&(r.delete(s),r.set(u,o)),this.mapClientToServerViewport.set(s,u);let c=o.handleSubscribed(t);c&&this.postMessageToClient(c),this.sendMessageToServer({type:ie,vpId:u}),this.sendMessageToServer({type:ae,vpId:u})}}break;case Ve:{let o=this.viewports.get(t.viewPortId);o&&(this.mapClientToServerViewport.delete(o.clientViewportId),r.delete(t.viewPortId))}break;case Ie:let a=this.viewports.get(t.vpId);a&&a.completeOperation(s);break;case J:case te:if(r.has(t.viewPortId)){let o=this.viewports.get(t.viewPortId);if(o){let u=o.completeOperation(s);u&&this.postMessageToClient(u)}}break;case ne:{let o=this.viewports.get(t.viewPortId);if(o){let u=o.completeOperation(s);if(u){this.postMessageToClient(u);let c=o.currentData(),l={type:"viewport-updates",viewports:{[o.clientViewportId]:{rows:c}}};this.postMessageToClient(l)}}}break;case be:{let{timeStamp:o}=t,[{ts:u}={ts:o}]=t.rows||Fe;for(let c of t.rows){let{viewPortId:l,rowIndex:p,rowKey:V,updateType:C}=c,d=r.get(l);d?d.isTree&&C==="U"&&!V.startsWith("$root")?console.log("Ignore blank rows sent after GroupBy"):d.handleUpdate(C,p,c):console.warn(`TABLE_ROW message received for non registered viewport ${l}`)}this.processUpdates(u)}break;case z:{let o=this.viewports.get(t.viewPortId);if(o){let{from:u,to:c}=t;o.completeOperation(s,u,c)}}break;case he:case Y:break;case j:{let o=this.viewports.get(t.childVpId),u=this.viewports.get(t.parentVpId);if(o&&u){let{childColumnName:c,parentColumnName:l}=t,p=o.completeOperation(s,c,u.clientViewportId,l);p&&this.postMessageToClient(p)}}break;case N:this.postMessageToClient({type:N,tables:t.tables,requestId:s});break;case A:this.postMessageToClient({type:A,table:t.table,columns:t.columns,dataTypes:t.dataTypes,requestId:s});break;case Se:{let o=this.getActiveLinks(t.links),u=this.viewports.get(t.vpId);if(o.length&&u){let[c,l]=u.setLinks(o);if(this.postMessageToClient(c),l){let{colName:p,parentViewportId:V,parentColName:C}=l,d=g(),E=this.mapClientToServerViewport.get(V);if(E){let w=u.createLink(d,p,E,C);this.sendMessageToServer(w,d)}}}}break;case ue:if(t.menu.name){let o=this.viewports.get(t.vpId);if(o){let u=o.setMenu(t.menu);this.postMessageToClient(u)}}break;case P:{let{action:o}=t;this.postMessageToClient({type:P,action:o,tableAlreadyOpen:this.isTableOpen(o.table),requestId:s})}break;case L:{let{method:o,result:u}=t;this.postMessageToClient({type:L,method:o,result:u,requestId:s})}break;case"ERROR":console.error(t.msg);break;default:console.log(`handleMessageFromServer ${t.type}.`)}}isTableOpen(e){if(e){let t=e.table;for(let s of this.viewports.values())if(!s.suspended&&s.table.table===t)return!0}}getActiveLinks(e){return e.filter(t=>{let s=this.viewports.get(t.parentVpId);return s&&!s.suspended})}processUpdates(e){let t;this.viewports.forEach(s=>{if(s.hasUpdatesToProcess){let n=s.getClientRows(e),r=s.getNewRowCount();(r!==void 0||n&&n.length>0)&&(t=t||{type:"viewport-updates",viewports:{}},t.viewports[s.clientViewportId]={rows:n,size:r})}t&&this.postMessageToClient(t)})}};var f;async function We(i,e,t){let s=await H(i,n=>Me(n)?t(n):f.handleMessageFromServer(n));console.log("[Worker] create the ServerProxy and wait for login to complete"),f=new R(s,n=>qe(n)),s.requiresLogin&&(console.group("[Worker].connectToServer login required, about to block await server login"),await f.login(e),console.groupEnd())}var W=0,De=[];function qe(i){let e=Math.round(performance.now());W&&De.push(e-W),postMessage(i),W=e}var Ge=async({data:i})=>{switch(i.type){case"connect":console.group(`[Worker] 'connect' request received token=${i.token}, about to block until connected`),await We(i.url,i.token,postMessage),console.groupEnd(),postMessage({type:"connected"});break;case"subscribe":f.subscribe(i);break;case"unsubscribe":f.unsubscribe(i.viewport);break;default:f.handleMessageFromClient(i)}};self.addEventListener("message",Ge);postMessage({type:"ready"});
}
