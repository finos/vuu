{
  "version": 3,
  "sources": ["../../packages/data-remote/src/websocket-connection.ts", "../../packages/data-remote/src/server-proxy/messages.ts", "../../packages/data-remote/src/server-proxy/keyset.ts", "../../packages/utils/src/input-utils.ts", "../../packages/utils/src/range-utils.ts", "../../packages/data-remote/src/server-proxy/buffer-range.ts", "../../packages/data-remote/src/server-proxy/array-backed-moving-window.ts", "../../packages/data-remote/src/server-proxy/viewport.ts", "../../packages/data-remote/src/server-proxy/rpc-services.js", "../../packages/data-remote/src/vuuUIMessageTypes.ts", "../../packages/data-remote/src/server-proxy/server-proxy.ts", "../../packages/data-remote/src/worker.ts"],
  "sourcesContent": ["import { ServerToClientMessage, ClientToServerMessage } from '@vuu-ui/data-types';\nimport { Connection } from './connectionTypes';\n\nimport { ConnectionStatus, ConnectionStatusMessage } from './vuuUIMessageTypes';\n\nexport type ConnectionMessage = ServerToClientMessage | ConnectionStatusMessage;\nexport type ConnectionCallback = (msg: ConnectionMessage) => void;\n\n// TEST_DATA_COLLECTION\n// import { saveTestData } from './test-data-collection';\n\nconst logger = console;\n\nconst connectionAttempts: {\n  [key: string]: { attemptsRemaining: number; status: ConnectionStatus };\n} = {};\n\nconst setWebsocket = Symbol('setWebsocket');\nconst connectionCallback = Symbol('connectionCallback');\n\nexport async function connect(connectionString: string, callback: ConnectionCallback) {\n  return makeConnection(connectionString, callback);\n}\n\nasync function reconnect(connection: WebsocketConnection) {\n  //TODO it's not enough to reconnect with a new websocket, we have to log back in as well\n  makeConnection(connection.url, connection[connectionCallback], connection);\n}\n\nasync function makeConnection(\n  url: string,\n  callback: ConnectionCallback,\n  connection?: WebsocketConnection\n): Promise<Connection | undefined> {\n  const connectionStatus =\n    connectionAttempts[url] ||\n    (connectionAttempts[url] = {\n      attemptsRemaining: 5,\n      status: 'disconnected'\n    });\n\n  try {\n    callback({ type: 'connection-status', status: 'connecting' });\n    const reconnecting = typeof connection !== 'undefined';\n    const ws = await createWebsocket(url);\n\n    console.log(\n      `%c\u26A1 %c${url}`,\n      'font-size: 24px;color: green;font-weight: bold;',\n      'color:green; font-size: 14px;'\n    );\n\n    if (connection !== undefined) {\n      connection[setWebsocket](ws);\n    }\n\n    const websocketConnection = connection ?? new WebsocketConnection(ws, url, callback);\n\n    const status = reconnecting ? 'reconnected' : 'connected';\n    callback({ type: 'connection-status', status });\n    websocketConnection.status = status;\n\n    return websocketConnection as Connection;\n  } catch (evt) {\n    const retry = --connectionStatus.attemptsRemaining > 0;\n    callback({\n      type: 'connection-status',\n      status: 'disconnected',\n      reason: 'failed to connect',\n      retry\n    });\n    if (retry) {\n      return makeConnectionIn(url, callback, connection, 10000);\n    }\n  }\n}\n\nconst makeConnectionIn = (\n  url: string,\n  callback: ConnectionCallback,\n  connection?: WebsocketConnection,\n  delay?: number\n): Promise<Connection | undefined> =>\n  new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(makeConnection(url, callback, connection));\n    }, delay);\n  });\n\nconst createWebsocket = (connectionString: string): Promise<WebSocket> =>\n  new Promise((resolve, reject) => {\n    //TODO add timeout\n    const ws = new WebSocket('ws://' + connectionString);\n    ws.onopen = () => resolve(ws);\n    ws.onerror = (evt) => reject(evt);\n  });\n\nconst closeWarn = () => {\n  logger.log(`Connection cannot be closed, socket not yet opened`);\n};\n\nconst sendWarn = (msg: ClientToServerMessage) => {\n  logger.log(`Message cannot be sent, socket closed: ${msg.body.type}`);\n};\n\nconst parseMessage = (message: string): ServerToClientMessage => {\n  try {\n    return JSON.parse(message) as ServerToClientMessage;\n  } catch (e) {\n    throw Error(`Error parsing JSON response from server ${message}`);\n  }\n};\n\nexport class WebsocketConnection implements Connection<ClientToServerMessage> {\n  [connectionCallback]: ConnectionCallback;\n  close: () => void = closeWarn;\n  requiresLogin = true;\n  send: (msg: ClientToServerMessage) => void = sendWarn;\n  status: 'closed' | 'ready' | 'connected' | 'reconnected' = 'ready';\n  url: string;\n\n  constructor(ws: any, url: string, callback: ConnectionCallback) {\n    this.url = url;\n    this[connectionCallback] = callback;\n    this[setWebsocket](ws);\n  }\n\n  reconnect() {\n    reconnect(this);\n  }\n\n  [setWebsocket](ws: WebSocket) {\n    const callback = this[connectionCallback];\n\n    ws.onmessage = (evt) => {\n      // TEST DATA COLLECTION\n      // saveTestData(evt.data, 'server');\n      const vuuMessageFromServer = parseMessage(evt.data);\n      // console.log(\n      //   `%c<<< [${new Date().toISOString().slice(11, 23)}]  (WebSocket) ${message.body.type}\n      //   ${JSON.stringify(message)}\n      //   `,\n      //   'color:white;background-color:blue;font-weight:bold;'\n      // );\n      callback(vuuMessageFromServer);\n    };\n\n    ws.onerror = () => {\n      console.log(\n        `%c\u26A1 %c${this.url}`,\n        'font-size: 24px;color: red;font-weight: bold;',\n        'color:red; font-size: 14px;'\n      );\n      callback({\n        type: 'connection-status',\n        status: 'disconnected',\n        reason: 'error'\n      });\n      if (this.status !== 'closed') {\n        reconnect(this);\n        this.send = queue;\n      }\n    };\n\n    ws.onclose = () => {\n      console.log(\n        `%c\u26A1 %c${this.url}`,\n        'font-size: 24px;color: orange;font-weight: bold;',\n        'color:orange; font-size: 14px;'\n      );\n      callback({\n        type: 'connection-status',\n        status: 'disconnected',\n        reason: 'close'\n      });\n      if (this.status !== 'closed') {\n        reconnect(this);\n        this.send = queue;\n      }\n    };\n\n    const send = (msg: ClientToServerMessage) => {\n      // console.log(`%c>>>  (WebSocket) ${JSON.stringify(msg)}`, 'color:blue;font-weight:bold;');\n      ws.send(JSON.stringify(msg));\n    };\n\n    const queue = (msg: ClientToServerMessage) => {\n      console.log(`queuing message ${JSON.stringify(msg)} until websocket reconnected`);\n    };\n\n    this.send = send;\n\n    this.close = () => {\n      console.log('[Connection] close websocket');\n      this.status = 'closed';\n      ws.close();\n      this.close = closeWarn;\n      this.send = sendWarn;\n    };\n  }\n}\n", "export const AUTH = 'AUTH';\nexport const AUTH_SUCCESS = 'AUTH_SUCCESS';\nexport const CHANGE_VP = 'CHANGE_VP';\nexport const CHANGE_VP_SUCCESS = 'CHANGE_VP_SUCCESS';\nexport const CHANGE_VP_RANGE = 'CHANGE_VP_RANGE';\nexport const CHANGE_VP_RANGE_SUCCESS = 'CHANGE_VP_RANGE_SUCCESS';\nexport const CLOSE_TREE_NODE = 'CLOSE_TREE_NODE';\nexport const CLOSE_TREE_SUCCESS = 'CLOSE_TREE_SUCCESS';\nexport const CLOSE_TREE_REJECT = 'CLOSE_TREE_REJECT';\nexport const CREATE_VISUAL_LINK = 'CREATE_VISUAL_LINK';\nexport const CREATE_VISUAL_LINK_SUCCESS = 'CREATE_VISUAL_LINK_SUCCESS';\nexport const CREATE_VP = 'CREATE_VP';\nexport const CREATE_VP_SUCCESS = 'CREATE_VP_SUCCESS';\nexport const DISABLE_VP = 'DISABLE_VP';\nexport const DISABLE_VP_SUCCESS = 'DISABLE_VP_SUCCESS';\nexport const DISABLE_VP_REJECT = 'DISABLE_VP_REJECT';\nexport const ENABLE_VP = 'ENABLE_VP';\nexport const ENABLE_VP_SUCCESS = 'ENABLE_VP_SUCCESS';\nexport const ENABLE_VP_REJECT = 'ENABLE_VP_REJECT';\nexport const GET_TABLE_LIST = 'GET_TABLE_LIST';\nexport const GET_TABLE_META = 'GET_TABLE_META';\nexport const GET_VP_VISUAL_LINKS = 'GET_VP_VISUAL_LINKS';\nexport const GET_VIEW_PORT_MENUS = 'GET_VIEW_PORT_MENUS';\nexport const VIEW_PORT_MENUS_RESP = 'VIEW_PORT_MENUS_RESP';\nexport const VIEW_PORT_MENUS_SELECT_RPC = 'VIEW_PORT_MENUS_SELECT_RPC';\nexport const VIEW_PORT_MENU_CELL_RPC = 'VIEW_PORT_MENU_CELL_RPC';\nexport const VIEW_PORT_MENU_TABLE_RPC = 'VIEW_PORT_MENU_TABLE_RPC';\nexport const VIEW_PORT_MENU_ROW_RPC = 'VIEW_PORT_MENU_ROW_RPC';\nexport const VIEW_PORT_MENU_RESP = 'VIEW_PORT_MENU_RESP';\nexport const VIEW_PORT_MENU_REJ = 'VIEW_PORT_MENU_REJ';\nexport const HB = 'HB';\nexport const HB_RESP = 'HB_RESP';\nexport const LOGIN = 'LOGIN';\nexport const LOGIN_SUCCESS = 'LOGIN_SUCCESS';\nexport const OPEN_TREE_NODE = 'OPEN_TREE_NODE';\nexport const OPEN_TREE_SUCCESS = 'OPEN_TREE_SUCCESS';\nexport const OPEN_TREE_REJECT = 'OPEN_TREE_REJECT';\nexport const REMOVE_VP = 'REMOVE_VP';\nexport const REMOVE_VP_SUCCESS = 'REMOVE_VP_SUCCESS';\nexport const REMOVE_VP_REJECT = 'REMOVE_VP_REJECT';\nexport const RPC_CALL = 'RPC_CALL';\nexport const RPC_RESP = 'RPC_RESP';\nexport const MENU_RPC_CALL = 'MENU_RPC_CALL';\nexport const MENU_RPC_RESP = 'MENU_RPC_RESP';\nexport const SET_SELECTION = 'SET_SELECTION';\nexport const SET_SELECTION_SUCCESS = 'SET_SELECTION_SUCCESS';\nexport const TABLE_META_RESP = 'TABLE_META_RESP';\nexport const TABLE_LIST_RESP = 'TABLE_LIST_RESP';\nexport const VP_VISUAL_LINKS_RESP = 'VP_VISUAL_LINKS_RESP';\n\nexport const TABLE_ROW = 'TABLE_ROW';\nexport const SIZE = 'SIZE';\nexport const UPDATE = 'U';\n", "import { VuuRange } from '@vuu-ui/data-types';\n\nexport class KeySet {\n  private keys: Map<number, number>;\n  private free: number[];\n  private nextKeyValue: number;\n\n  constructor(range: VuuRange) {\n    this.keys = new Map();\n    this.free = [];\n    this.nextKeyValue = 0;\n    this.reset(range);\n  }\n\n  public next(): number {\n    if (this.free.length > 0) {\n      return this.free.pop() as number;\n    } else {\n      return this.nextKeyValue++;\n    }\n  }\n\n  public reset({ from, to }: VuuRange) {\n    this.keys.forEach((keyValue, rowIndex) => {\n      if (rowIndex < from || rowIndex >= to) {\n        this.free.push(keyValue);\n        this.keys.delete(rowIndex);\n      }\n    });\n\n    const size = to - from;\n    if (this.keys.size + this.free.length > size) {\n      this.free.length = size - this.keys.size;\n    }\n\n    for (let rowIndex = from; rowIndex < to; rowIndex++) {\n      if (!this.keys.has(rowIndex)) {\n        const nextKeyValue = this.next();\n        this.keys.set(rowIndex, nextKeyValue);\n      }\n    }\n  }\n\n  public keyFor(rowIndex: number): number {\n    const key = this.keys.get(rowIndex);\n    if (key === undefined) {\n      throw Error(`KeySet, no key found for rowIndex ${rowIndex}`);\n    }\n    return key;\n  }\n}\n", "const actionKeys = {\n  Enter: 'Enter',\n  Delete: 'Delete'\n};\n\nconst navigationKeys = {\n  Home: 'Home',\n  End: 'End',\n  ArrowRight: 'ArrowRight',\n  ArrowLeft: 'ArrowLeft',\n  ArrowDown: 'ArrowDown',\n  ArrowUp: 'ArrowUp',\n  Tab: 'Tab'\n};\nconst functionKeys = {\n  F1: 'F1',\n  F2: 'F2',\n  F3: 'F3',\n  F4: 'F4',\n  F5: 'F5',\n  F6: 'F6',\n  F7: 'F7',\n  F8: 'F8',\n  F9: 'F9',\n  F10: 'F10',\n  F11: 'F11',\n  F12: 'F12'\n};\n\nconst specialKeys = {\n  ...actionKeys,\n  ...navigationKeys,\n  ...functionKeys\n};\ntype specialKey = keyof typeof specialKeys;\n\nconst isSpecialKey = (key: string): key is specialKey => key in specialKeys;\n\nexport const isCharacterKey = (evt: KeyboardEvent) => {\n  if (isSpecialKey(evt.key)) {\n    return false;\n  }\n  if (typeof evt.which === 'number' && evt.which > 0) {\n    return !evt.ctrlKey && !evt.metaKey && !evt.altKey && evt.which !== 8;\n  }\n};\n\nexport const isQuoteKey = (evt: KeyboardEvent) => {\n  return evt.key === '\"' || evt.key === \"'\";\n};\n", "export interface VuuRange {\n  from: number;\n  to: number;\n  bufferSize?: number;\n  reset?: boolean;\n}\n\ninterface FromToRange {\n  from: number;\n  to: number;\n}\n\nexport function getFullRange(\n  { from, to }: VuuRange,\n  bufferSize: number = 0,\n  rowCount: number = Number.MAX_SAFE_INTEGER\n): FromToRange {\n  if (bufferSize === 0) {\n    return { from, to: Math.min(to, rowCount) };\n  } else if (from === 0) {\n    return { from, to: Math.min(to + bufferSize, rowCount) };\n  } else {\n    const rangeSize = to - from;\n    const buff = Math.round(bufferSize / 2);\n    const shortfallBefore = from - buff < 0;\n    const shortFallAfter = rowCount - (to + buff) < 0;\n\n    if (shortfallBefore && shortFallAfter) {\n      return { from: 0, to: rowCount };\n    } else if (shortfallBefore) {\n      return { from: 0, to: rangeSize + bufferSize };\n    } else if (shortFallAfter) {\n      return { from: Math.max(0, rowCount - (rangeSize + bufferSize)), to: rowCount };\n    } else {\n      return { from: from - buff, to: to + buff };\n    }\n  }\n}\n\nexport function resetRange({ from, to, bufferSize = 0 }: VuuRange): VuuRange {\n  return {\n    from: 0,\n    to: to - from,\n    bufferSize,\n    reset: true\n  };\n}\n\nexport class WindowRange {\n  public from: number;\n  public to: number;\n\n  constructor(from: number, to: number) {\n    this.from = from;\n    this.to = to;\n  }\n\n  public isWithin(index: number) {\n    return index >= this.from && index < this.to;\n  }\n\n  //find the overlap of this range and a new one\n  public overlap(from: number, to: number): [number, number] {\n    return from >= this.to || to < this.from\n      ? [0, 0]\n      : [Math.max(from, this.from), Math.min(to, this.to)];\n  }\n\n  public copy(): WindowRange {\n    return new WindowRange(this.from, this.to);\n  }\n}\n", "export interface FromToRange {\n  from: number;\n  to: number;\n}\n\nexport const bufferBreakout = (range: FromToRange, from: number, to: number, bufferSize: number): boolean => {\n  const bufferPerimeter = bufferSize * 0.25;\n  if (!range || !bufferSize) {\n    return true;\n  } else if (range.to - to < bufferPerimeter) {\n    return true;\n  } else if (range.from > 0 && from - range.from < bufferPerimeter) {\n    return true;\n  } else {\n    return false;\n  }\n};\n", "import { WindowRange } from '@vuu-ui/utils';\nimport { bufferBreakout } from './buffer-range';\nimport { VuuRange, VuuRow } from '@vuu-ui/data-types';\n\nconst EMPTY_ARRAY = [] as const;\n\ntype RangeTuple = [boolean, readonly VuuRow[], readonly VuuRow[]];\n\nexport class ArrayBackedMovingWindow {\n  private bufferSize: number;\n  private range: WindowRange;\n  private internalData: any[];\n  private rowsWithinRange: number;\n\n  public clientRange: WindowRange;\n  public rowCount: number;\n\n  // Note, the buffer is already accounted for in the range passed in here\n  constructor(\n    { from: clientFrom, to: clientTo }: VuuRange,\n    { from, to }: VuuRange,\n    bufferSize: number\n  ) {\n    this.bufferSize = bufferSize;\n    this.clientRange = new WindowRange(clientFrom, clientTo);\n    this.range = new WindowRange(from, to);\n    //internal data is always 0 based, we add range.from to determine an offset\n    this.internalData = new Array(bufferSize);\n    this.rowsWithinRange = 0;\n    this.rowCount = 0;\n  }\n\n  // TODO we shpuld probably have a hasAllClientRowsWithinRange\n  get hasAllRowsWithinRange(): boolean {\n    return (\n      this.rowsWithinRange === this.clientRange.to - this.clientRange.from ||\n      // this.rowsWithinRange === this.range.to - this.range.from ||\n      (this.rowCount > 0 && this.rowsWithinRange === this.rowCount)\n    );\n  }\n\n  setRowCount = (rowCount: number) => {\n    if (rowCount < this.internalData.length) {\n      this.internalData.length = rowCount;\n    }\n    if (rowCount < this.rowCount) {\n      // Brute force, works\n      this.rowsWithinRange = 0;\n      const end = Math.min(rowCount, this.clientRange.to);\n      for (let i = this.clientRange.from; i < end; i++) {\n        const rowIndex = i - this.range.from;\n        if (this.internalData[rowIndex] !== undefined) {\n          this.rowsWithinRange += 1;\n        }\n      }\n    }\n    this.rowCount = rowCount;\n  };\n\n  setAtIndex(index: number, data: any) {\n    const isWithinClientRange = this.isWithinClientRange(index);\n    if (isWithinClientRange || this.isWithinRange(index)) {\n      const internalIndex = index - this.range.from;\n      if (!this.internalData[internalIndex] && isWithinClientRange) {\n        this.rowsWithinRange += 1;\n        //onsole.log(`rowsWithinRange is now ${this.rowsWithinRange} out of ${this.range.to - this.range.from}`)\n      }\n      this.internalData[internalIndex] = data;\n    }\n    return isWithinClientRange;\n  }\n\n  getAtIndex(index: number): any {\n    return this.range.isWithin(index) && this.internalData[index - this.range.from] != null\n      ? this.internalData[index - this.range.from]\n      : undefined;\n  }\n\n  isWithinRange(index: number): boolean {\n    return this.range.isWithin(index);\n  }\n\n  isWithinClientRange(index: number): boolean {\n    return this.clientRange.isWithin(index);\n  }\n\n  // Returns [false] or [serverDataRequired, clientRows, holdingRows]\n  setClientRange(from: number, to: number): RangeTuple {\n    const currentFrom = this.clientRange.from;\n    const currentTo = Math.min(this.clientRange.to, this.rowCount);\n\n    if (from === currentFrom && to === currentTo) {\n      return [false, EMPTY_ARRAY, EMPTY_ARRAY] as RangeTuple;\n    }\n\n    const originalRange = this.clientRange.copy();\n    this.clientRange.from = from;\n    this.clientRange.to = to;\n    this.rowsWithinRange = 0;\n    for (let i = from; i < to; i++) {\n      const internalIndex = i - this.range.from;\n      if (this.internalData[internalIndex]) {\n        this.rowsWithinRange += 1;\n      }\n    }\n\n    let clientRows: readonly VuuRow[] = EMPTY_ARRAY;\n    let holdingRows: readonly VuuRow[] = EMPTY_ARRAY;\n    const offset = this.range.from;\n\n    if (this.hasAllRowsWithinRange) {\n      if (to > originalRange.to) {\n        const start = Math.max(from, originalRange.to);\n        clientRows = this.internalData.slice(start - offset, to - offset);\n      } else {\n        const end = Math.min(originalRange.from, to);\n        clientRows = this.internalData.slice(from - offset, end - offset);\n      }\n    } else if (this.rowsWithinRange > 0) {\n      if (to > originalRange.to) {\n        const start = Math.max(from, originalRange.to);\n        holdingRows = this.internalData.slice(start - offset, to - offset).filter((row) => !!row);\n      } else {\n        const end = Math.max(originalRange.from, to);\n        holdingRows = this.internalData\n          .slice(Math.max(0, from - offset), end - offset)\n          .filter((row) => !!row);\n      }\n    }\n\n    const serverDataRequired = bufferBreakout(this.range, from, to, this.bufferSize);\n    return [serverDataRequired, clientRows, holdingRows] as RangeTuple;\n  }\n\n  setRange(from: number, to: number) {\n    const [overlapFrom, overlapTo] = this.range.overlap(from, to);\n\n    const newData = new Array(to - from + this.bufferSize);\n    this.rowsWithinRange = 0;\n\n    for (let i = overlapFrom; i < overlapTo; i++) {\n      const data = this.getAtIndex(i);\n      if (data) {\n        const index = i - from;\n        newData[index] = data;\n        if (this.isWithinClientRange(i)) {\n          this.rowsWithinRange += 1;\n        }\n      }\n    }\n\n    this.internalData = newData;\n    this.range.from = from;\n    this.range.to = to;\n  }\n\n  getData(): any[] {\n    const { from, to } = this.range;\n    const { from: clientFrom, to: clientTo } = this.clientRange;\n    const startOffset = Math.max(0, clientFrom - from);\n    // TEMP hack, whu wouldn't we have rowCount ?\n    const endOffset = Math.min(to - from, to, clientTo - from, this.rowCount ?? to);\n    // const endOffset = Math.min(to-from, to, hi - from, this.rowCount);\n    return this.internalData.slice(startOffset, endOffset);\n  }\n}\n", "import { KeySet } from './keyset';\nimport * as Message from './messages';\nimport { ArrayBackedMovingWindow } from './array-backed-moving-window';\nimport { getFullRange } from '@vuu-ui/utils/src/range-utils';\nimport { bufferBreakout } from './buffer-range';\nimport {\n  ServerToClientCreateViewPortSuccess,\n  ClientToServerCreateLink,\n  ClientToServerCreateViewPort,\n  ClientToServerDisable,\n  ClientToServerEnable,\n  ClientToServerSelection,\n  ClientToServerViewPortRange,\n  VuuColumns,\n  VuuMenu,\n  VuuGroupBy,\n  VuuLink,\n  VuuRow,\n  VuuTable,\n  VuuAggregation,\n  VuuSortCol,\n  VuuRange\n} from '@vuu-ui/data-types';\nimport {\n  ServerProxySubscribeMessage,\n  VuuUIMessageInDisabled,\n  VuuUIMessageInEnabled,\n  VuuUIMessageInFilter,\n  VuuUIMessageInGroupBy,\n  VuuUIMessageInSubscribed,\n  VuuUIMessageInMenus,\n  VuuUIMessageInSort,\n  VuuUIMessageInViewPortVisualLinks,\n  VuuUIMessageInVisualLinkCreated,\n  VuuUIRow,\n  VuuUIRowPredicate\n} from '../vuuUIMessageTypes';\n\nconst EMPTY_ARRAY: unknown[] = [];\nconst EMPTY_GROUPBY: VuuGroupBy = [];\n\ninterface Disable {\n  type: 'disable';\n}\ninterface Enable {\n  type: 'enable';\n}\ninterface ChangeViewportRange {\n  type: 'CHANGE_VP_RANGE';\n}\ninterface Filter {\n  data: { filter: any; filterQuery: string };\n  type: 'filter';\n}\ninterface Aggregate {\n  data: VuuAggregation[];\n  type: 'aggregate';\n}\ninterface Selection {\n  data: number[];\n  type: 'selection';\n}\ninterface Sort {\n  data: VuuSortCol[];\n  type: 'sort';\n}\ninterface GroupBy {\n  data: VuuGroupBy;\n  type: 'groupBy';\n}\ninterface GroupByClear {\n  data: VuuGroupBy;\n  type: 'groupByClear';\n}\ntype CreateVisualLink = ClientToServerCreateLink;\n\ntype AsyncOperation =\n  | Aggregate\n  | ChangeViewportRange\n  | CreateVisualLink\n  | Disable\n  | Enable\n  | Filter\n  | GroupBy\n  | GroupByClear\n  | Selection\n  | Sort;\ntype RangeRequestTuple = [ClientToServerViewPortRange | null, VuuUIRow[]?];\ntype RowSortPredicate = (row1: VuuUIRow, row2: VuuUIRow) => number;\n\nconst byRowIndex: RowSortPredicate = ([index1], [index2]) => index1 - index2;\nexport class Viewport {\n  private aggregations: any;\n  private bufferSize: number;\n  private clientRange: VuuRange;\n  private columns: any[];\n  // TODO create this in constructor so we don't have to mark is as optional\n  private dataWindow?: ArrayBackedMovingWindow = undefined;\n  private disabled: boolean = false;\n  private filter: any;\n  private filterSpec: any;\n  private groupBy: any;\n  private hasUpdates: boolean = false;\n  private holdingPen: VuuUIRow[] = [];\n  private keys: any;\n  private lastTouchIdx: number | null = null;\n  private links: VuuLink[] = [];\n  private linkedParent: any = null;\n  private pendingLinkedParent: any;\n  private pendingOperations: any = new Map<string, AsyncOperation>();\n  private pendingRangeRequest: any = null;\n  private rowCountChanged: boolean = false;\n  private sort: any;\n\n  public clientViewportId: string;\n  public isTree: boolean = false;\n  public serverViewportId?: string;\n  public status: '' | 'subscribed' = '';\n  public suspended: boolean = false;\n  public table: VuuTable;\n\n  constructor({\n    viewport,\n    tablename,\n    aggregations,\n    columns,\n    range,\n    bufferSize = 50,\n    filter = '',\n    filterQuery = '',\n    sort = [],\n    groupBy = [],\n    visualLink\n  }: ServerProxySubscribeMessage) {\n    this.clientViewportId = viewport;\n    this.table = tablename;\n    this.aggregations = aggregations;\n    this.columns = columns;\n    this.clientRange = range;\n    this.bufferSize = bufferSize;\n    this.sort = {\n      sortDefs: sort\n    };\n    this.groupBy = groupBy;\n    this.filterSpec = {\n      filter: filterQuery\n    };\n    this.filter = filter;\n    this.keys = new KeySet(range);\n    this.pendingLinkedParent = visualLink;\n  }\n\n  get hasUpdatesToProcess() {\n    if (this.suspended) {\n      return false;\n    }\n    return this.rowCountChanged || this.hasUpdates;\n  }\n\n  subscribe() {\n    return {\n      type: Message.CREATE_VP,\n      table: this.table,\n      range: getFullRange(this.clientRange, this.bufferSize),\n      aggregations: this.aggregations,\n      columns: this.columns,\n      sort: this.sort,\n      groupBy: this.groupBy,\n      filterSpec: this.filterSpec\n    } as ClientToServerCreateViewPort;\n  }\n\n  handleSubscribed({\n    viewPortId,\n    aggregations,\n    columns,\n    range,\n    sort,\n    groupBy,\n    filterSpec\n  }: ServerToClientCreateViewPortSuccess) {\n    this.serverViewportId = viewPortId;\n    this.status = 'subscribed';\n    this.aggregations = aggregations;\n    this.columns = columns;\n    this.groupBy = groupBy;\n    this.filterSpec = filterSpec;\n    this.isTree = groupBy && groupBy.length > 0;\n    this.dataWindow = new ArrayBackedMovingWindow(this.clientRange, range, this.bufferSize);\n\n    console.log(\n      `%cViewport subscribed\n        clientVpId: ${this.clientViewportId}\n        serverVpId: ${this.serverViewportId}\n        table: ${this.table}\n        aggregations: ${JSON.stringify(aggregations)}\n        columns: ${columns.join(',')}\n        range: ${JSON.stringify(range)}\n        sort: ${JSON.stringify(sort)}\n        groupBy: ${JSON.stringify(groupBy)}\n        filterSpec: ${JSON.stringify(filterSpec)}\n        bufferSize: ${this.bufferSize}\n      `,\n      'color: blue'\n    );\n\n    return {\n      type: 'subscribed',\n      clientViewportId: this.clientViewportId,\n      columns,\n      filter: this.filter,\n      filterSpec: this.filterSpec\n    } as VuuUIMessageInSubscribed;\n  }\n\n  awaitOperation(requestId: string, msg: AsyncOperation) {\n    //TODO set uip a timeout mechanism here\n    this.pendingOperations.set(requestId, msg);\n  }\n\n  // Return a message if we need to communicate this to client UI\n  completeOperation(requestId: string, ...params: unknown[]) {\n    const { clientViewportId, pendingOperations } = this;\n    const { type, data } = pendingOperations.get(requestId);\n    pendingOperations.delete(requestId);\n    if (type === Message.CHANGE_VP_RANGE) {\n      const [from, to] = params as [number, number];\n      this.dataWindow?.setRange(from, to);\n      //this.hasUpdates = true; // is this right ??????????\n      this.pendingRangeRequest = null;\n    } else if (type === 'groupBy') {\n      this.isTree = true;\n      this.groupBy = data;\n      return { clientViewportId, type, groupBy: data } as VuuUIMessageInGroupBy;\n    } else if (type === 'groupByClear') {\n      this.isTree = false;\n      this.groupBy = [];\n      return { clientViewportId, type: 'groupBy', groupBy: null } as VuuUIMessageInGroupBy;\n    } else if (type === 'filter') {\n      this.filterSpec = { filter: data.filterQuery };\n      return { clientViewportId, type, ...data } as VuuUIMessageInFilter;\n    } else if (type === 'aggregate') {\n      this.aggregations = data;\n      return { clientViewportId, type, aggregations: data };\n    } else if (type === 'sort') {\n      this.sort = { sortDefs: data };\n      return { clientViewportId, type, sort: data } as VuuUIMessageInSort;\n    } else if (type === 'selection') {\n      // should we do this here ?\n      // this.selection = data;\n    } else if (type === 'disable') {\n      this.disabled = true; // assuming its _SUCCESS, of course\n      return {\n        type: 'disabled',\n        clientViewportId\n      } as VuuUIMessageInDisabled;\n    } else if (type === 'enable') {\n      this.disabled = false;\n      return {\n        type: 'enabled',\n        clientViewportId\n      } as VuuUIMessageInEnabled;\n    } else if (type === Message.CREATE_VISUAL_LINK) {\n      const [colName, parentViewportId, parentColName] = params;\n      this.linkedParent = {\n        colName,\n        parentViewportId,\n        parentColName\n      };\n      this.pendingLinkedParent = null;\n      return {\n        type: 'visual-link-created',\n        clientViewportId,\n        colName,\n        parentViewportId,\n        parentColName\n      } as VuuUIMessageInVisualLinkCreated;\n    }\n  }\n\n  rangeRequest(requestId: string, range: VuuRange): RangeRequestTuple {\n    // If we can satisfy the range request from the buffer, we will.\n    // May or may not need to make a server request, depending on status of buffer\n    const type = Message.CHANGE_VP_RANGE;\n    // If dataWindow has all data for the new range, it will return the\n    // delta of rows which are in the new range but were not in the\n    // previous range.\n    // Note: what if it doesn't have the entire range but DOES have all\n    // rows that constitute the delta ? Is this even possible ?\n\n    if (this.dataWindow) {\n      const [serverDataRequired, clientRows, holdingRows] = this.dataWindow.setClientRange(\n        range.from,\n        range.to\n      );\n      const serverRequest =\n        serverDataRequired &&\n        bufferBreakout(this.pendingRangeRequest, range.from, range.to, this.bufferSize)\n          ? ({\n              type,\n              viewPortId: this.serverViewportId,\n              ...getFullRange(range, this.bufferSize, this.dataWindow.rowCount)\n            } as ClientToServerViewPortRange)\n          : null;\n      if (serverRequest) {\n        // TODO check that there os not already a pending server request for more data\n        this.awaitOperation(requestId, { type });\n        this.pendingRangeRequest = serverRequest;\n      }\n\n      // always reset the keys here, even if we're not going to return rows immediately.\n      this.keys.reset(this.dataWindow.clientRange);\n\n      const rowWithinRange: VuuUIRowPredicate = ([index]) =>\n        index < range.from || index >= range.to;\n      if (this.holdingPen.some(rowWithinRange)) {\n        this.holdingPen = this.holdingPen.filter(\n          ([index]) => index >= range.from && index < range.to\n        );\n      }\n\n      const toClient = this.isTree ? toClientRowTree(this.groupBy, this.columns) : toClientRow;\n\n      if (holdingRows.length) {\n        holdingRows.forEach((row) => {\n          this.holdingPen.push(toClient(row, this.keys));\n        });\n      }\n\n      if (clientRows.length) {\n        return [\n          serverRequest,\n          clientRows.map((row) => {\n            return toClient(row, this.keys);\n          })\n        ];\n      } else {\n        return [serverRequest];\n      }\n    } else {\n      return [null];\n    }\n  }\n\n  setLinks(links: VuuLink[]) {\n    this.links = links;\n    return [\n      {\n        type: 'VP_VISUAL_LINKS_RESP',\n        links,\n        clientViewportId: this.clientViewportId\n      },\n      this.pendingLinkedParent\n    ] as [VuuUIMessageInViewPortVisualLinks, any];\n  }\n\n  setMenu(menu: VuuMenu) {\n    return {\n      type: 'VIEW_PORT_MENUS_RESP',\n      menu,\n      clientViewportId: this.clientViewportId\n    } as VuuUIMessageInMenus;\n  }\n\n  createLink(requestId: string, colName: string, parentVpId: string, parentColumnName: string) {\n    const message = {\n      type: Message.CREATE_VISUAL_LINK,\n      parentVpId,\n      childVpId: this.serverViewportId,\n      parentColumnName,\n      childColumnName: colName\n    } as CreateVisualLink;\n    this.awaitOperation(requestId, message);\n    return message as ClientToServerCreateLink;\n  }\n\n  suspend() {\n    this.suspended = true;\n  }\n\n  resume() {\n    this.suspended = false;\n    return this.currentData();\n  }\n\n  currentData() {\n    const out = [];\n    if (this.dataWindow) {\n      const records = this.dataWindow.getData();\n      const { keys } = this;\n      const toClient = this.isTree ? toClientRowTree(this.groupBy, this.columns) : toClientRow;\n      for (let row of records) {\n        if (row) {\n          out.push(toClient(row, keys));\n        }\n      }\n    }\n    return out;\n  }\n\n  enable(requestId: string) {\n    this.awaitOperation(requestId, { type: 'enable' });\n    return {\n      type: Message.ENABLE_VP,\n      viewPortId: this.serverViewportId\n    } as ClientToServerEnable;\n  }\n\n  disable(requestId: string) {\n    this.awaitOperation(requestId, { type: 'disable' });\n    return {\n      type: Message.DISABLE_VP,\n      viewPortId: this.serverViewportId\n    } as ClientToServerDisable;\n  }\n\n  filterRequest(requestId: string, filter: any, filterQuery: string) {\n    this.awaitOperation(requestId, { type: 'filter', data: { filter, filterQuery } });\n    return this.createRequest({ filterSpec: { filter: filterQuery } });\n  }\n\n  aggregateRequest(requestId: string, aggregations: VuuAggregation[]) {\n    this.awaitOperation(requestId, { type: 'aggregate', data: aggregations });\n    return this.createRequest({ aggregations });\n  }\n\n  sortRequest(requestId: string, sortCols: VuuSortCol[]) {\n    this.awaitOperation(requestId, { type: 'sort', data: sortCols });\n    return this.createRequest({ sort: { sortDefs: sortCols } });\n  }\n\n  groupByRequest(requestId: string, groupBy: VuuGroupBy = EMPTY_GROUPBY) {\n    const type = groupBy === EMPTY_ARRAY ? 'groupByClear' : 'groupBy';\n    this.awaitOperation(requestId, { type, data: groupBy });\n    return this.createRequest({ groupBy });\n  }\n\n  selectRequest(requestId: string, selection: number[]) {\n    // TODO we need to do this in the client if we are to raise selection events\n    // TODO is it right to set this here or should we wait for ACK from server ?\n    this.awaitOperation(requestId, { type: 'selection', data: selection });\n    return {\n      type: Message.SET_SELECTION,\n      vpId: this.serverViewportId,\n      selection\n    } as ClientToServerSelection;\n  }\n\n  handleUpdate(updateType: string, rowIndex: number, row: VuuRow) {\n    if (this.dataWindow) {\n      if (this.dataWindow.rowCount !== row.vpSize) {\n        this.dataWindow.setRowCount(row.vpSize);\n        this.rowCountChanged = true;\n      }\n      if (updateType === 'U') {\n        // Update will return true if row was within client range\n        if (this.dataWindow.setAtIndex(rowIndex, row)) {\n          this.hasUpdates = true;\n        }\n      }\n    }\n  }\n\n  getNewRowCount = () => {\n    if (this.rowCountChanged && this.dataWindow) {\n      this.rowCountChanged = false;\n      return this.dataWindow.rowCount;\n    }\n  };\n\n  // This is called only after new data has been received from server - data\n  // returned direcly from buffer does not use this.\n  // If we have updates, but we don't yet have data for the full client range\n  // in our buffer, store them in the holding pen. We know the remaining rows\n  // have been requested and will arrive imminently. Soon as we receive data,\n  // contents of holding pen plus additional rows received that fill the range\n  // will be dispatched to client.\n  // If we have any rows in the holding pen, and we now have a full set of\n  // client data, make sure we empty the pen and send those rows to client,\n  // along qith the new data.\n  // TODO what if we're going backwards\n  getClientRows(timeStamp: number) {\n    if (this.hasUpdates && this.dataWindow) {\n      const records = this.dataWindow.getData();\n      const { keys } = this;\n      const toClient = this.isTree ? toClientRowTree(this.groupBy, this.columns) : toClientRow;\n\n      // NOte this should probably just check that we havs all client rows within range ?\n      const clientRows = this.dataWindow.hasAllRowsWithinRange\n        ? this.holdingPen.splice(0)\n        : undefined;\n\n      const out = clientRows || this.holdingPen;\n\n      for (let row of records) {\n        if (row && row.ts >= timeStamp) {\n          out.push(toClient(row, keys));\n        }\n      }\n      this.hasUpdates = false;\n\n      // this only matters where we scroll backwards and have holdingPen data\n      // should we test for that explicitly ?\n      return clientRows && clientRows.sort(byRowIndex);\n    }\n  }\n\n  createRequest(params: any) {\n    return {\n      type: Message.CHANGE_VP,\n      viewPortId: this.serverViewportId,\n      aggregations: this.aggregations,\n      columns: this.columns,\n      sort: this.sort,\n      groupBy: this.groupBy,\n      filterSpec: this.filterSpec,\n      ...params\n    };\n  }\n}\n\nconst toClientRow = ({ rowIndex, rowKey, sel: isSelected, data }: VuuRow, keys: KeySet) =>\n  [rowIndex, keys.keyFor(rowIndex), true, null, null, 1, rowKey, isSelected].concat(\n    data\n  ) as VuuUIRow;\n\nconst toClientRowTree =\n  (groupBy: VuuGroupBy, columns: VuuColumns) =>\n  ({ rowIndex, rowKey, sel: isSelected, data }: VuuRow, keys: KeySet) => {\n    let [depth, isExpanded /* path */, , isLeaf /* label */, , count, ...rest] = data;\n\n    // TODO do we need this - the data is already there\n    const steps = rowKey.split('|').slice(1);\n    groupBy.forEach((col, i) => {\n      const idx = columns.indexOf(col);\n      rest[idx] = steps[i];\n    });\n\n    const record = [\n      rowIndex,\n      keys.keyFor(rowIndex),\n      isLeaf,\n      isExpanded,\n      depth,\n      count,\n      rowKey,\n      isSelected\n    ].concat(rest);\n\n    return record as VuuUIRow;\n  };\n", "export const getRpcService = (method) => {\n  switch (method) {\n    case 'getUniqueFieldValues':\n      return ['TypeAheadRpcHandler', 'TYPEAHEAD'];\n    default:\n      return ['OrderEntryRpcHandler', 'SIMUL'];\n  }\n};\n", "import { msgType } from './constants';\nimport {\n  VuuAggregation,\n  VuuColumns,\n  VuuFilter,\n  VuuGroupBy,\n  VuuLink,\n  VuuMenu,\n  VuuMenuContext,\n  VuuRange,\n  VuuSort,\n  VuuSortCol,\n  VuuTable\n} from '@vuu-ui/data-types';\n\nexport type ConnectionStatus = 'connecting' | 'connected' | 'disconnected' | 'reconnected';\n\nexport interface ConnectionStatusMessage {\n  type: 'connection-status';\n  reason?: string;\n  retry?: boolean;\n  status: ConnectionStatus;\n}\n\nexport const isConnectionStatusMessage = (msg: object): msg is ConnectionStatusMessage =>\n  (msg as ConnectionStatusMessage).type === 'connection-status';\n\nexport type VuuUIRow = [number, string, boolean, any, any, number, string, boolean, ...any[]];\n\nexport type VuuUIRowPredicate = (row: VuuUIRow) => boolean;\n\nexport interface ServerProxySubscribeMessage {\n  aggregations: any;\n  bufferSize?: number;\n  columns: VuuColumns;\n  filter: any;\n  filterQuery: any;\n  groupBy: any;\n  range: VuuRange;\n  sort: any;\n  tablename: VuuTable;\n  viewport: string;\n  visualLink: any;\n}\n\n// export type VuuUIMessageInConnectionStatus = {\n//   type: 'connection-status';\n// };\n\nexport type VuuUIMessageInConnected = {\n  type: 'connected';\n};\n\nexport type VuuUIMessageInWorkerReady = {\n  type: 'ready';\n};\n\nexport interface ViewportMessage {\n  clientViewportId: string;\n}\n\nexport interface VuuUIMessageInDisabled extends ViewportMessage {\n  type: 'disabled';\n}\nexport interface VuuUIMessageInEnabled extends ViewportMessage {\n  type: 'enabled';\n}\n\nexport interface VuuUIMessageInSubscribed extends ViewportMessage {\n  aggregations: VuuAggregation[];\n  columns: VuuColumns;\n  filter: any;\n  filterSpec: VuuFilter;\n  groupBy: VuuGroupBy;\n  range: VuuRange;\n  type: 'subscribed';\n}\n\nexport interface VuuUIMessageInFilter extends ViewportMessage {\n  type: 'filter';\n  filter: any;\n  filterQuery: any;\n}\n\nexport interface VuuUIMessageInGroupBy extends ViewportMessage {\n  type: 'groupBy';\n  groupBy: VuuGroupBy | null;\n}\nexport interface VuuUIMessageInSort extends ViewportMessage {\n  type: 'sort';\n  sort: VuuSort;\n}\n\nexport type VuuUIMessageInViewportUpdates = {\n  type: 'viewport-updates';\n  viewports: {\n    [viewport: string]: {\n      rows?: VuuUIRow[];\n      size?: number;\n    };\n  };\n};\n\nexport type VuuUIMessageInViewportUpdate = {\n  type: 'viewport-update';\n  rows: VuuUIRow[];\n  size: number;\n};\n\nexport interface VuuUIMessageInRPC {\n  method: string;\n  result: any;\n  requestId: string;\n  type: 'RPC_RESP';\n}\n\nexport interface VuuUIMessageInTableList {\n  requestId: string;\n  type: 'TABLE_LIST_RESP';\n  tables: VuuTable[];\n}\nexport interface VuuUIMessageInTableMeta {\n  columns: string[];\n  dataTypes: string[];\n  requestId: string;\n  table: VuuTable;\n  type: 'TABLE_META_RESP';\n}\nexport interface VuuUIMessageInViewPortVisualLinks {\n  type: 'VP_VISUAL_LINKS_RESP';\n  links: VuuLink[];\n  clientViewportId: string;\n}\nexport interface VuuUIMessageInVisualLinkCreated {\n  clientViewportId: string;\n  colName: string;\n  parentViewportId: string;\n  parentColName: string;\n  type: 'visual-link-created';\n}\nexport interface VuuUIMessageInMenus {\n  type: 'VIEW_PORT_MENUS_RESP';\n  menu: VuuMenu;\n  clientViewportId: string;\n}\nexport interface VuuUIMessageInMenu {\n  action: {\n    table: VuuTable;\n  };\n  requestId: string;\n  tableAlreadyOpen?: boolean;\n  type: 'VIEW_PORT_MENU_RESP';\n}\n\nexport type VuuUIMessageIn =\n  | VuuUIMessageInDisabled\n  | VuuUIMessageInEnabled\n  | VuuUIMessageInConnected\n  // | VuuUIMessageInConnectionStatus\n  | VuuUIMessageInWorkerReady\n  | VuuUIMessageInFilter\n  | VuuUIMessageInGroupBy\n  | VuuUIMessageInSubscribed\n  | VuuUIMessageInViewportUpdate\n  | VuuUIMessageInViewportUpdates\n  | VuuUIMessageInRPC\n  | VuuUIMessageInMenu\n  | VuuUIMessageInMenus\n  | VuuUIMessageInSort\n  | VuuUIMessageInViewPortVisualLinks\n  | VuuUIMessageInVisualLinkCreated\n  | VuuUIMessageInTableList\n  | VuuUIMessageInTableMeta;\n\nexport interface VuuUIMessageOutConnect {\n  type: 'connect';\n  token: string;\n  url: string;\n  useWebsocket: boolean;\n}\n\nexport interface VuuUIMessageOutSubscribe extends ServerProxySubscribeMessage {\n  type: 'subscribe';\n}\n\nexport interface VuuUIMessageOutUnsubscribe {\n  type: 'unsubscribe';\n  viewport: string;\n}\n\nexport interface ViewportMessage {\n  viewport: string;\n}\n\nexport interface RequestMessage {\n  requestId: string;\n}\n\nexport interface VuuUIMessageOutViewRange extends ViewportMessage {\n  type: 'setViewRange';\n  range: {\n    from: number;\n    to: number;\n  };\n}\nexport interface VuuUIMessageOutAggregate extends ViewportMessage {\n  aggregations: VuuAggregation[];\n  type: 'aggregate';\n}\nexport interface VuuUIMessageOutCloseTreeNode extends ViewportMessage {\n  key: string;\n  type: 'closeTreeNode';\n}\nexport interface VuuUIMessageOutCreateLink extends ViewportMessage {\n  childColumnName: string;\n  parentColumnName: string;\n  parentVpId: string;\n  type: 'createLink';\n}\n\nexport interface VuuUIMessageOutDisable extends ViewportMessage {\n  type: 'disable';\n}\nexport interface VuuUIMessageOutEnable extends ViewportMessage {\n  type: 'enable';\n}\nexport interface VuuUIMessageOutOpenTreeNode extends ViewportMessage {\n  key: string;\n  type: 'openTreeNode';\n}\nexport interface VuuUIMessageOutResume extends ViewportMessage {\n  type: 'resume';\n}\n\nexport interface VuuUIMessageOutSelect extends ViewportMessage {\n  selected: number[];\n  type: 'select';\n}\n\nexport interface VuuUIMessageOutSort extends ViewportMessage {\n  sortCriteria: VuuSortCol[];\n  type: 'sort';\n}\nexport interface VuuUIMessageOutSuspend extends ViewportMessage {\n  type: 'suspend';\n}\n\nexport interface VuuUIMessageOutFilterQuery extends ViewportMessage {\n  filter: any;\n  filterQuery: string;\n  type: 'filterQuery';\n}\nexport interface VuuUIMessageOutGroupby extends ViewportMessage {\n  groupBy: any[];\n  type: 'groupBy';\n}\n\nexport interface VuuUIMessageOutMenuRPC extends RequestMessage, ViewportMessage {\n  context: VuuMenuContext;\n  rpcName: string;\n  type: 'MENU_RPC_CALL';\n}\n\nexport type VuuUIMessageOutViewport =\n  | VuuUIMessageOutAggregate\n  | VuuUIMessageOutCloseTreeNode\n  | VuuUIMessageOutCreateLink\n  | VuuUIMessageOutFilterQuery\n  | VuuUIMessageOutDisable\n  | VuuUIMessageOutEnable\n  | VuuUIMessageOutGroupby\n  | VuuUIMessageOutOpenTreeNode\n  | VuuUIMessageOutResume\n  | VuuUIMessageOutSelect\n  | VuuUIMessageOutSuspend\n  | VuuUIMessageOutSort\n  | VuuUIMessageOutViewRange\n  | VuuUIMessageOutMenuRPC;\n\nexport const isViewporttMessage = (msg: object): msg is VuuUIMessageOutViewport =>\n  'viewport' in msg;\n\nexport interface VuuUIMessageOutRPC extends RequestMessage {\n  method: string;\n  params: any[];\n  type: 'RPC_CALL';\n}\n\nexport type VuuUIMessageOutRpcCall = VuuUIMessageOutRPC | VuuUIMessageOutMenuRPC;\n\nexport interface VuuUIMessageOutTableList extends RequestMessage {\n  type: 'GET_TABLE_LIST';\n}\n\nexport interface VuuUIMessageOutTableMeta extends RequestMessage {\n  type: 'GET_TABLE_META';\n  table: VuuTable;\n}\n\nexport type VuuUIMessageOutAsyncRequest = VuuUIMessageOutTableList | VuuUIMessageOutTableMeta;\n\nexport const isAsyncRequestMessage = (msg: object): msg is VuuUIMessageOutAsyncRequest =>\n  'requestId' in msgType;\n\nexport type VuuUIMessageOut =\n  | VuuUIMessageOutConnect\n  | VuuUIMessageOutSubscribe\n  | VuuUIMessageOutUnsubscribe\n  | VuuUIMessageOutAsyncRequest\n  | VuuUIMessageOutViewport\n  | VuuUIMessageOutRpcCall;\n\nexport type RpcRequest = {};\nexport type RpcResponse = {};\n\nexport type TableMeta = {};\nexport type TableList = {};\n\n// These are the messages sent to the client data source\nexport type ClientViewportMessage = {};\n", "import * as Message from './messages';\nimport { Viewport } from './viewport';\nimport { getRpcService } from './rpc-services';\nimport { Connection } from '../connectionTypes';\nimport {\n  ServerToClientMessage,\n  ClientToServerMessage,\n  VuuLink,\n  VuuMenuContext,\n  VuuTable\n} from '@vuu-ui/data-types';\nimport {\n  isViewporttMessage as isViewportMessage,\n  ServerProxySubscribeMessage,\n  VuuUIMessageIn,\n  VuuUIMessageInTableList,\n  VuuUIMessageInTableMeta,\n  VuuUIMessageInViewportUpdates,\n  VuuUIMessageOut,\n  VuuUIMessageOutAggregate,\n  VuuUIMessageOutConnect,\n  VuuUIMessageOutCreateLink,\n  VuuUIMessageOutDisable,\n  VuuUIMessageOutEnable,\n  VuuUIMessageOutFilterQuery,\n  VuuUIMessageOutGroupby,\n  VuuUIMessageOutMenuRPC,\n  VuuUIMessageOutRPC,\n  VuuUIMessageOutOpenTreeNode,\n  VuuUIMessageOutCloseTreeNode,\n  VuuUIMessageOutSelect,\n  VuuUIMessageOutSort,\n  VuuUIMessageOutSubscribe,\n  VuuUIMessageOutUnsubscribe,\n  VuuUIMessageOutViewRange\n} from '../vuuUIMessageTypes';\n\nexport type PostMessageToClientCallback = (message: VuuUIMessageIn) => void;\n\n// TEST_DATA_COLLECTION\n// import { saveTestData } from '../../test-data-collection';\n\nlet _requestId: number = 1;\nexport const TEST_setRequestId = (id: number) => (_requestId = id);\n\nconst nextRequestId = () => `${_requestId++}`;\nconst EMPTY_ARRAY: unknown[] = [];\nconst DEFAULT_OPTIONS = {};\n\nconst getRPCType = (\n  msgType: 'MENU_RPC_CALL',\n  context: VuuMenuContext\n): 'VIEW_PORT_MENUS_SELECT_RPC' => {\n  if (msgType === 'MENU_RPC_CALL' && context === 'selected-rows') {\n    return 'VIEW_PORT_MENUS_SELECT_RPC';\n  } else {\n    throw Error('No RPC command for ${msgType} / ${context}');\n  }\n};\n\ninterface PendingLogin {\n  resolve: (value: any) => void; // TODO\n  reject: () => void;\n}\nexport class ServerProxy {\n  private connection: Connection;\n  private postMessageToClient: PostMessageToClientCallback;\n  private viewports: Map<string, Viewport>;\n  private mapClientToServerViewport: Map<string, string>;\n  private authToken?: string;\n  private pendingLogin?: PendingLogin;\n  private sessionId?: string;\n  private queuedRequests: Array<ClientToServerMessage['body']> = [];\n\n  constructor(connection: Connection, callback: PostMessageToClientCallback) {\n    this.connection = connection;\n    this.postMessageToClient = callback;\n    this.viewports = new Map<string, Viewport>();\n    this.mapClientToServerViewport = new Map();\n  }\n\n  public async login(authToken?: string) {\n    if (authToken) {\n      this.authToken = authToken;\n    }\n    const token = this.authToken;\n    if (token === undefined) {\n      throw Error(`ServerProxy login, cannot login until auth token has been obtained`);\n    }\n    return new Promise((resolve, reject) => {\n      this.sendMessageToServer({ type: Message.LOGIN, token, user: 'user' }, '');\n      this.pendingLogin = { resolve, reject };\n    });\n  }\n\n  public subscribe(message: ServerProxySubscribeMessage) {\n    // guard against subscribe message when a viewport is already subscribed\n    if (!this.mapClientToServerViewport.has(message.viewport)) {\n      const viewport = new Viewport(message);\n      this.viewports.set(message.viewport, viewport);\n      // use client side viewport as request id, so that when we process the response,\n      // with the serverside viewport we can establish a mapping between the two\n      this.sendIfReady(viewport.subscribe(), message.viewport, this.sessionId !== '');\n    } else {\n      console.log(`ServerProxy spurious subscribe call ${message.viewport}`);\n    }\n  }\n\n  public unsubscribe(clientViewportId: string) {\n    const serverViewportId = this.mapClientToServerViewport.get(clientViewportId);\n    if (serverViewportId) {\n      this.sendMessageToServer({\n        type: Message.REMOVE_VP,\n        viewPortId: serverViewportId\n      });\n    } else {\n      console.error(`ServerProxy: failed to unsubscribe client viewport ${clientViewportId}`);\n    }\n  }\n\n  private getViewportForClient(clientViewportId: string): Viewport {\n    const serverViewportId = this.mapClientToServerViewport.get(clientViewportId);\n    if (serverViewportId) {\n      const viewport = this.viewports.get(serverViewportId);\n      if (viewport) {\n        return viewport;\n      } else {\n        throw Error(`Viewport not found for client viewport ${clientViewportId}`);\n      }\n    } else {\n      throw Error(`Viewport server id not found for client viewport ${clientViewportId}`);\n    }\n  }\n\n  /**********************************************************************/\n  /* Handle messages from client                                        */\n  /**********************************************************************/\n  private setViewRange(viewport: Viewport, message: VuuUIMessageOutViewRange) {\n    const requestId = nextRequestId();\n    const [serverRequest, rows] = viewport.rangeRequest(requestId, message.range);\n    if (serverRequest) {\n      this.sendIfReady(serverRequest, requestId, viewport.status === 'subscribed');\n    }\n    if (rows) {\n      this.postMessageToClient({\n        type: 'viewport-updates',\n        viewports: {\n          [viewport.clientViewportId]: { rows }\n        }\n      });\n    }\n  }\n\n  private aggregate(viewport: Viewport, message: VuuUIMessageOutAggregate) {\n    const requestId = nextRequestId();\n    const request = viewport.aggregateRequest(requestId, message.aggregations);\n    this.sendIfReady(request, requestId, viewport.status === 'subscribed');\n  }\n\n  private sort(viewport: Viewport, message: VuuUIMessageOutSort) {\n    const requestId = nextRequestId();\n    const request = viewport.sortRequest(requestId, message.sortCriteria);\n    this.sendIfReady(request, requestId, viewport.status === 'subscribed');\n  }\n\n  private groupBy(viewport: Viewport, message: VuuUIMessageOutGroupby) {\n    const requestId = nextRequestId();\n    const request = viewport.groupByRequest(requestId, message.groupBy);\n    this.sendIfReady(request, requestId, viewport.status === 'subscribed');\n  }\n\n  private filter(viewport: Viewport, message: VuuUIMessageOutFilterQuery) {\n    const requestId = nextRequestId();\n    const { filter, filterQuery } = message;\n    const request = viewport.filterRequest(requestId, filter, filterQuery);\n    this.sendIfReady(request, requestId, viewport.status === 'subscribed');\n  }\n\n  private select(viewport: Viewport, message: VuuUIMessageOutSelect) {\n    const requestId = nextRequestId();\n    const { selected } = message;\n    const request = viewport.selectRequest(requestId, selected);\n    this.sendIfReady(request, requestId, viewport.status === 'subscribed');\n  }\n\n  //TODO when do we ever checj the disabled state ?\n  private disableViewport(viewport: Viewport, message: VuuUIMessageOutDisable) {\n    const requestId = nextRequestId();\n    const request = viewport.disable(requestId);\n    this.sendIfReady(request, requestId, viewport.status === 'subscribed');\n  }\n\n  private enableViewport(viewport: Viewport, message: VuuUIMessageOutEnable) {\n    const requestId = nextRequestId();\n    const request = viewport.enable(requestId);\n    this.sendIfReady(request, requestId, viewport.status === 'subscribed');\n  }\n\n  private resumeViewport(viewport: Viewport) {\n    const rows = viewport.resume();\n    this.postMessageToClient({\n      type: 'viewport-updates',\n      viewports: {\n        [viewport.clientViewportId]: { rows }\n      }\n    });\n  }\n\n  private openTreeNode(viewport: Viewport, message: VuuUIMessageOutOpenTreeNode) {\n    if (viewport.serverViewportId) {\n      this.sendIfReady(\n        {\n          type: Message.OPEN_TREE_NODE,\n          vpId: viewport.serverViewportId,\n          treeKey: message.key\n        },\n        nextRequestId(),\n        viewport.status === 'subscribed'\n      );\n    }\n  }\n\n  private closeTreeNode(viewport: Viewport, message: VuuUIMessageOutCloseTreeNode) {\n    if (viewport.serverViewportId) {\n      this.sendIfReady(\n        {\n          type: Message.CLOSE_TREE_NODE,\n          vpId: viewport.serverViewportId,\n          treeKey: message.key\n        },\n        nextRequestId(),\n        viewport.status === 'subscribed'\n      );\n    }\n  }\n\n  private createLink(viewport: Viewport, message: VuuUIMessageOutCreateLink) {\n    const { parentVpId, parentColumnName, childColumnName } = message;\n    const requestId = nextRequestId();\n    const request = viewport.createLink(requestId, childColumnName, parentVpId, parentColumnName);\n    this.sendMessageToServer(request, requestId);\n  }\n\n  private menuRpcCall(viewport: Viewport, message: VuuUIMessageOutMenuRPC) {\n    if (viewport.serverViewportId) {\n      const { context, rpcName } = message;\n      this.sendMessageToServer(\n        {\n          type: getRPCType(message.type, context),\n          rpcName,\n          vpId: viewport.serverViewportId\n        },\n        message.requestId\n      );\n    }\n  }\n\n  private rpcCall(message: VuuUIMessageOutRPC) {\n    // below duplicated - tidy up\n    const { method, requestId, type } = message;\n    const [service, module] = getRpcService(method);\n    this.sendMessageToServer(\n      {\n        type,\n        service,\n        method,\n        params: message.params /*|| [viewport.serverViewportId]*/,\n        namedParams: {}\n      },\n      requestId,\n      { module }\n    );\n  }\n\n  public handleMessageFromClient(\n    message: Exclude<\n      VuuUIMessageOut,\n      VuuUIMessageOutConnect | VuuUIMessageOutSubscribe | VuuUIMessageOutUnsubscribe\n    >\n  ) {\n    if (isViewportMessage(message)) {\n      const viewport = this.getViewportForClient(message.viewport);\n      switch (message.type) {\n        case 'setViewRange':\n          return this.setViewRange(viewport, message);\n        case 'aggregate':\n          return this.aggregate(viewport, message);\n        case 'sort':\n          return this.sort(viewport, message);\n        case 'groupBy':\n          return this.groupBy(viewport, message);\n        case 'filterQuery':\n          return this.filter(viewport, message);\n        case 'select':\n          return this.select(viewport, message);\n        case 'suspend':\n          return viewport.suspend();\n        case 'resume':\n          return this.resumeViewport(viewport);\n        case 'disable':\n          return this.disableViewport(viewport, message);\n        case 'enable':\n          return this.enableViewport(viewport, message);\n        case 'openTreeNode':\n          return this.openTreeNode(viewport, message);\n        case 'closeTreeNode':\n          return this.closeTreeNode(viewport, message);\n        case 'createLink':\n          return this.createLink(viewport, message);\n        case 'MENU_RPC_CALL':\n          return this.menuRpcCall(viewport, message);\n        default:\n      }\n    } else {\n      const { type, requestId } = message;\n      switch (type) {\n        case Message.GET_TABLE_LIST:\n          return this.sendMessageToServer({ type }, requestId);\n        case Message.GET_TABLE_META:\n          return this.sendMessageToServer({ type, table: message.table }, requestId);\n        case Message.RPC_CALL:\n          return this.rpcCall(message);\n        default:\n      }\n    }\n    console.log(`Vuu ServerProxy Unexpected message from client ${JSON.stringify(message)}`);\n    // TEST DATA COLLECTION\n    // saveTestData(message, 'client');\n    //---------------------\n  }\n\n  public sendIfReady(\n    message: ClientToServerMessage['body'],\n    requestId: string,\n    isReady: boolean = true,\n    options?: any\n  ) {\n    // TODO implement the message queuing in remote data view\n    if (isReady) {\n      this.sendMessageToServer(message, requestId, options);\n    } else {\n      // TODO need to make sure we keep the requestId\n      this.queuedRequests.push(message);\n    }\n    return isReady;\n  }\n\n  public sendMessageToServer(\n    body: ClientToServerMessage['body'],\n    requestId: string = `${_requestId++}`,\n    options: any = DEFAULT_OPTIONS\n  ) {\n    const { module = 'CORE', ...restOptions } = options;\n    // const { clientId } = this.connection;\n    if (this.authToken) {\n      this.connection.send(\n        {\n          requestId,\n          sessionId: this.sessionId,\n          token: this.authToken,\n          user: 'user',\n          module,\n          body\n        } as ClientToServerMessage\n        // restOptions\n      );\n    }\n  }\n\n  public handleMessageFromServer(message: ServerToClientMessage) {\n    const { body, requestId, sessionId } = message;\n\n    // onsole.log(`%c<<< [${new Date().toISOString().slice(11,23)}]  (ServerProxy) ${message.type || JSON.stringify(message)}`,'color:white;background-color:blue;font-weight:bold;');\n\n    const { viewports } = this;\n    switch (body.type) {\n      case Message.HB:\n        this.sendMessageToServer({ type: Message.HB_RESP, ts: +new Date() }, 'NA');\n        break;\n\n      case Message.LOGIN_SUCCESS:\n        this.sessionId = sessionId;\n        this.pendingLogin?.resolve(sessionId);\n        break;\n\n      case Message.CREATE_VP_SUCCESS:\n        {\n          const viewport = viewports.get(requestId);\n          // The clientViewportId was used as requestId for CREATE_VP message\n          if (viewport) {\n            const { viewPortId: serverViewportId } = body;\n\n            if (requestId !== serverViewportId) {\n              viewports.delete(requestId);\n              viewports.set(serverViewportId, viewport);\n            }\n            this.mapClientToServerViewport.set(requestId, serverViewportId);\n            const response = viewport.handleSubscribed(body);\n            if (response) {\n              this.postMessageToClient(response);\n            }\n            this.sendMessageToServer({ type: Message.GET_VP_VISUAL_LINKS, vpId: serverViewportId });\n            this.sendMessageToServer({ type: Message.GET_VIEW_PORT_MENUS, vpId: serverViewportId });\n          }\n        }\n        break;\n\n      case Message.REMOVE_VP_SUCCESS:\n        {\n          const viewport = this.viewports.get(body.viewPortId);\n          if (viewport) {\n            // do we need a destroy method on viewport for cleanup ?\n            this.mapClientToServerViewport.delete(viewport.clientViewportId);\n            viewports.delete(body.viewPortId);\n          }\n        }\n        break;\n\n      case Message.SET_SELECTION_SUCCESS:\n        const viewport = this.viewports.get(body.vpId);\n        if (viewport) {\n          viewport.completeOperation(requestId);\n        }\n        break;\n\n      case Message.CHANGE_VP_SUCCESS:\n      case Message.DISABLE_VP_SUCCESS:\n        if (viewports.has(body.viewPortId)) {\n          const viewport = this.viewports.get(body.viewPortId);\n          if (viewport) {\n            const response = viewport.completeOperation(requestId);\n            if (response) {\n              this.postMessageToClient(response);\n            }\n          }\n        }\n\n        break;\n\n      case Message.ENABLE_VP_SUCCESS:\n        {\n          const viewport = this.viewports.get(body.viewPortId);\n          if (viewport) {\n            const response = viewport.completeOperation(requestId);\n            if (response) {\n              this.postMessageToClient(response);\n              const rows = viewport.currentData();\n              const clientMessage = {\n                type: 'viewport-updates',\n                viewports: {\n                  [viewport.clientViewportId]: { rows }\n                }\n              } as VuuUIMessageInViewportUpdates;\n              this.postMessageToClient(clientMessage);\n            }\n          }\n        }\n        break;\n      case Message.TABLE_ROW:\n        {\n          const { timeStamp } = body;\n          const [{ ts: firstBatchTimestamp } = { ts: timeStamp }] = body.rows || EMPTY_ARRAY;\n          // onsole.log(`\\nbatch timestamp ${time(timeStamp)} first timestamp ${time(firstBatchTimestamp)} ${body.rows.length} rows in batch`)\n          for (const row of body.rows) {\n            const { viewPortId, rowIndex, rowKey, updateType } = row;\n            const viewport = viewports.get(viewPortId);\n            if (viewport) {\n              // onsole.log(`row timestamp ${time(row.ts)}`)\n              // This might miss rows if we receive rows after submitting a groupByRequest but before\n              // receiving the ACK\n              if (viewport.isTree && updateType === 'U' && !rowKey.startsWith('$root')) {\n                console.log('Ignore blank rows sent after GroupBy');\n              } else {\n                viewport.handleUpdate(updateType, rowIndex, row);\n              }\n            } else {\n              console.warn(`TABLE_ROW message received for non registered viewport ${viewPortId}`);\n            }\n            // onsole.log(`%c[ServerProxy] after updates, movingWindow has ${viewport.dataWindow.internalData.length} records`,'color:brown')\n          }\n\n          this.processUpdates(firstBatchTimestamp);\n        }\n        break;\n\n      case Message.CHANGE_VP_RANGE_SUCCESS:\n        {\n          const viewport = this.viewports.get(body.viewPortId);\n          if (viewport) {\n            const { from, to } = body;\n            viewport.completeOperation(requestId, from, to);\n          }\n        }\n        break;\n\n      case Message.OPEN_TREE_SUCCESS:\n      case Message.CLOSE_TREE_SUCCESS:\n        break;\n\n      case Message.CREATE_VISUAL_LINK_SUCCESS:\n        {\n          const viewport = this.viewports.get(body.childVpId);\n          const parentViewport = this.viewports.get(body.parentVpId);\n          if (viewport && parentViewport) {\n            const { childColumnName, parentColumnName } = body;\n            const response = viewport.completeOperation(\n              requestId,\n              childColumnName,\n              parentViewport.clientViewportId,\n              parentColumnName\n            );\n            if (response) {\n              this.postMessageToClient(response);\n            }\n          }\n        }\n        break;\n\n      case Message.TABLE_LIST_RESP:\n        this.postMessageToClient({\n          type: Message.TABLE_LIST_RESP,\n          tables: body.tables,\n          requestId\n        } as VuuUIMessageInTableList);\n        break;\n\n      case Message.TABLE_META_RESP:\n        this.postMessageToClient({\n          type: Message.TABLE_META_RESP,\n          table: body.table,\n          columns: body.columns,\n          dataTypes: body.dataTypes,\n          requestId\n        } as VuuUIMessageInTableMeta);\n        break;\n\n      /*\n\n  private createLink(viewport: Viewport, message: VuuUIMessageOutCreateLink) {\n    const { parentVpId, parentColumnName, childColumnName } = message;\n    const requestId = nextRequestId();\n    const request = viewport.createLink(requestId, childColumnName, parentVpId, parentColumnName);\n    this.sendMessageToServer(request, requestId);\n  }\n\n        */\n      case Message.VP_VISUAL_LINKS_RESP:\n        {\n          const links = this.getActiveLinks(body.links);\n          const viewport = this.viewports.get(body.vpId);\n          if (links.length && viewport) {\n            const [clientMessage, pendingLink] = viewport.setLinks(links);\n            this.postMessageToClient(clientMessage);\n            if (pendingLink) {\n              const { colName, parentViewportId, parentColName } = pendingLink;\n              const requestId = nextRequestId();\n              const serverViewportId = this.mapClientToServerViewport.get(parentViewportId);\n              if (serverViewportId) {\n                const message = viewport.createLink(\n                  requestId,\n                  colName,\n                  serverViewportId,\n                  parentColName\n                );\n                this.sendMessageToServer(message, requestId);\n              }\n            }\n          }\n        }\n        break;\n\n      case Message.VIEW_PORT_MENUS_RESP:\n        if (body.menu.name) {\n          const viewport = this.viewports.get(body.vpId);\n          if (viewport) {\n            const clientMessage = viewport.setMenu(body.menu);\n            this.postMessageToClient(clientMessage);\n          }\n        }\n        break;\n\n      case Message.VIEW_PORT_MENU_RESP:\n        {\n          const { action } = body;\n          this.postMessageToClient({\n            type: Message.VIEW_PORT_MENU_RESP,\n            action,\n            tableAlreadyOpen: this.isTableOpen(action.table),\n            requestId\n          });\n        }\n        break;\n\n      case Message.RPC_RESP:\n        {\n          const { method, result } = body;\n          // check to see if the orderEntry is already open on the page\n          this.postMessageToClient({\n            type: Message.RPC_RESP,\n            method,\n            result,\n            requestId\n          });\n        }\n        break;\n\n      case 'ERROR':\n        console.error(body.msg);\n        break;\n\n      default:\n        console.log(`handleMessageFromServer ${(body as any).type as string}.`);\n    }\n  }\n\n  isTableOpen(table?: VuuTable) {\n    if (table) {\n      const tableName = table.table;\n      for (let viewport of this.viewports.values()) {\n        if (!viewport.suspended && viewport.table.table === tableName) {\n          return true;\n        }\n      }\n    }\n  }\n\n  // Eliminate links to suspended viewports\n  getActiveLinks(links: VuuLink[]) {\n    return links.filter((link) => {\n      const viewport = this.viewports.get(link.parentVpId);\n      return viewport && !viewport.suspended;\n    });\n  }\n\n  processUpdates(timeStamp: number) {\n    let clientMessage: VuuUIMessageInViewportUpdates;\n    this.viewports.forEach((viewport) => {\n      if (viewport.hasUpdatesToProcess) {\n        const rows = viewport.getClientRows(timeStamp);\n        const size = viewport.getNewRowCount();\n        if (size !== undefined || (rows && rows.length > 0)) {\n          clientMessage = clientMessage || {\n            type: 'viewport-updates',\n            viewports: {}\n          };\n          clientMessage.viewports[viewport.clientViewportId] = { rows, size };\n        }\n      }\n      if (clientMessage) {\n        // const now = performance.now();\n        // if (updateTime){\n        //   onsole.log(`time between updates ${now - updateTime}`)\n        // }\n        // updateTime = now;\n        // Object.values(clientMessage.viewports).forEach(({rows, size}) =>\n        //   onsole.log(`%c[ServerProxy] processUpdates, posting ${rows.length} rows (size ${size})`,'color:brown')\n        // )\n        this.postMessageToClient(clientMessage);\n      }\n    });\n  }\n}\n", "import { connect as connectWebsocket } from '@vuu-ui/data-remote/src/websocket-connection';\nimport { ServerProxy } from '@vuu-ui/data-remote/src/server-proxy/server-proxy';\nimport {\n  ConnectionStatusMessage,\n  isConnectionStatusMessage,\n  VuuUIMessageOut\n} from '@vuu-ui/data-remote/src/vuuUIMessageTypes';\n\nlet server: ServerProxy;\n\nasync function connectToServer(\n  url: string,\n  token: string,\n  useWebsocket: boolean,\n  onConnectionStatusChange: (msg: ConnectionStatusMessage) => void\n) {\n  const connection = await connectWebsocket(\n    url,\n    // if this was called during connect, we would get a ReferenceError, but it will\n    // never be called until subscriptions have been made, so this is safe.\n    //TODO do we need to listen in to the connection messages here so we can lock back in, in the event of a reconnenct ?\n    (msg) =>\n      isConnectionStatusMessage(msg)\n        ? onConnectionStatusChange(msg)\n        : server.handleMessageFromServer(msg)\n  );\n\n  server = new ServerProxy(connection, (msg) => sendMessageToClient(msg));\n  if (connection.requiresLogin) {\n    await server.login(token);\n  }\n}\n\nlet lastTime = 0;\nconst timings = [];\n\nfunction sendMessageToClient(message: any) {\n  const now = Math.round(performance.now());\n  if (lastTime) {\n    timings.push(now - lastTime);\n\n    // if (timings.length % 100 === 0){\n    //   console.log(timings.join(', : '))\n    //   timings.length = 0;\n    // }\n  }\n  postMessage(message);\n  lastTime = now;\n}\n\nconst handleMessageFromClient = async ({ data: message }: MessageEvent<VuuUIMessageOut>) => {\n  switch (message.type) {\n    case 'connect':\n      await connectToServer(message.url, message.token, message.useWebsocket, postMessage);\n      postMessage({ type: 'connected' });\n      break;\n    case 'subscribe':\n      server.subscribe(message);\n      break;\n    case 'unsubscribe':\n      server.unsubscribe(message.viewport);\n      break;\n    // TEST DATA COLLECTION\n    // case 'send-websocket-data':\n    //   postMessage({ type: 'websocket-data', data: getTestMessages() });\n    //   break;\n    default:\n      server.handleMessageFromClient(message);\n  }\n};\n\n/* eslint-disable-next-line no-restricted-globals */\nself.addEventListener('message', handleMessageFromClient);\n\npostMessage({ type: 'ready' });\n"],
  "mappings": "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",
  "names": ["logger", "connectionAttempts", "setWebsocket", "connectionCallback", "connect", "connectionString", "callback", "makeConnection", "reconnect", "connection", "url", "connectionStatus", "reconnecting", "ws", "createWebsocket", "websocketConnection", "WebsocketConnection", "status", "retry", "makeConnectionIn", "delay", "resolve", "reject", "evt", "closeWarn", "sendWarn", "msg", "parseMessage", "message", "vuuMessageFromServer", "queue", "send", "CHANGE_VP", "CHANGE_VP_SUCCESS", "CHANGE_VP_RANGE", "CHANGE_VP_RANGE_SUCCESS", "CLOSE_TREE_NODE", "CLOSE_TREE_SUCCESS", "CREATE_VISUAL_LINK", "CREATE_VISUAL_LINK_SUCCESS", "CREATE_VP", "CREATE_VP_SUCCESS", "DISABLE_VP", "DISABLE_VP_SUCCESS", "ENABLE_VP", "ENABLE_VP_SUCCESS", "GET_TABLE_LIST", "GET_TABLE_META", "GET_VP_VISUAL_LINKS", "GET_VIEW_PORT_MENUS", "VIEW_PORT_MENUS_RESP", "VIEW_PORT_MENU_RESP", "HB", "HB_RESP", "LOGIN", "LOGIN_SUCCESS", "OPEN_TREE_NODE", "OPEN_TREE_SUCCESS", "REMOVE_VP", "REMOVE_VP_SUCCESS", "RPC_CALL", "RPC_RESP", "SET_SELECTION", "SET_SELECTION_SUCCESS", "TABLE_META_RESP", "TABLE_LIST_RESP", "VP_VISUAL_LINKS_RESP", "TABLE_ROW", "KeySet", "range", "from", "to", "keyValue", "rowIndex", "size", "nextKeyValue", "key", "actionKeys", "navigationKeys", "functionKeys", "specialKeys", "getFullRange", "from", "to", "bufferSize", "rowCount", "rangeSize", "buff", "shortfallBefore", "shortFallAfter", "WindowRange", "from", "to", "index", "bufferBreakout", "range", "from", "to", "bufferSize", "bufferPerimeter", "EMPTY_ARRAY", "ArrayBackedMovingWindow", "clientFrom", "clientTo", "from", "to", "bufferSize", "WindowRange", "rowCount", "end", "i", "rowIndex", "index", "data", "isWithinClientRange", "internalIndex", "currentFrom", "currentTo", "originalRange", "clientRows", "holdingRows", "offset", "start", "row", "bufferBreakout", "overlapFrom", "overlapTo", "newData", "startOffset", "endOffset", "EMPTY_ARRAY", "EMPTY_GROUPBY", "byRowIndex", "index1", "index2", "Viewport", "viewport", "tablename", "aggregations", "columns", "range", "bufferSize", "filter", "filterQuery", "sort", "groupBy", "visualLink", "KeySet", "CREATE_VP", "getFullRange", "viewPortId", "filterSpec", "ArrayBackedMovingWindow", "requestId", "msg", "params", "clientViewportId", "pendingOperations", "type", "data", "CHANGE_VP_RANGE", "from", "to", "CREATE_VISUAL_LINK", "colName", "parentViewportId", "parentColName", "serverDataRequired", "clientRows", "holdingRows", "serverRequest", "bufferBreakout", "rowWithinRange", "index", "toClient", "toClientRowTree", "toClientRow", "row", "links", "menu", "parentVpId", "parentColumnName", "message", "out", "records", "keys", "ENABLE_VP", "DISABLE_VP", "sortCols", "selection", "SET_SELECTION", "updateType", "rowIndex", "timeStamp", "CHANGE_VP", "rowKey", "isSelected", "depth", "isExpanded", "isLeaf", "count", "rest", "steps", "col", "i", "idx", "getRpcService", "method", "isConnectionStatusMessage", "msg", "isViewporttMessage", "_requestId", "nextRequestId", "_requestId", "EMPTY_ARRAY", "DEFAULT_OPTIONS", "getRPCType", "msgType", "context", "ServerProxy", "connection", "callback", "authToken", "token", "resolve", "reject", "LOGIN", "message", "viewport", "Viewport", "clientViewportId", "serverViewportId", "REMOVE_VP", "requestId", "serverRequest", "rows", "request", "filter", "filterQuery", "selected", "OPEN_TREE_NODE", "CLOSE_TREE_NODE", "parentVpId", "parentColumnName", "childColumnName", "rpcName", "method", "type", "service", "module", "getRpcService", "isViewporttMessage", "GET_TABLE_LIST", "GET_TABLE_META", "RPC_CALL", "isReady", "options", "body", "restOptions", "sessionId", "viewports", "HB", "HB_RESP", "LOGIN_SUCCESS", "CREATE_VP_SUCCESS", "response", "GET_VP_VISUAL_LINKS", "GET_VIEW_PORT_MENUS", "REMOVE_VP_SUCCESS", "SET_SELECTION_SUCCESS", "CHANGE_VP_SUCCESS", "DISABLE_VP_SUCCESS", "ENABLE_VP_SUCCESS", "clientMessage", "TABLE_ROW", "timeStamp", "firstBatchTimestamp", "row", "viewPortId", "rowIndex", "rowKey", "updateType", "CHANGE_VP_RANGE_SUCCESS", "from", "to", "OPEN_TREE_SUCCESS", "CLOSE_TREE_SUCCESS", "CREATE_VISUAL_LINK_SUCCESS", "parentViewport", "TABLE_LIST_RESP", "TABLE_META_RESP", "VP_VISUAL_LINKS_RESP", "links", "pendingLink", "colName", "parentViewportId", "parentColName", "VIEW_PORT_MENUS_RESP", "VIEW_PORT_MENU_RESP", "action", "RPC_RESP", "result", "table", "tableName", "link", "size", "server", "connectToServer", "url", "token", "useWebsocket", "onConnectionStatusChange", "connection", "connect", "msg", "isConnectionStatusMessage", "ServerProxy", "sendMessageToClient", "lastTime", "timings", "message", "now", "handleMessageFromClient"]
}
