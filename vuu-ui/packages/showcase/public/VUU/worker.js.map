{
  "version": 3,
  "sources": ["../../packages/data-remote/src/websocket-connection.ts", "../../packages/data-remote/src/server-proxy/messages.ts", "../../packages/data-remote/src/server-proxy/keyset.ts", "../../packages/utils/src/input-utils.ts", "../../packages/utils/src/range-utils.ts", "../../packages/data-remote/src/server-proxy/buffer-range.ts", "../../packages/data-remote/src/server-proxy/array-backed-moving-window.ts", "../../packages/data-remote/src/server-proxy/viewport.ts", "../../packages/data-remote/src/server-proxy/rpc-services.js", "../../packages/data-remote/src/vuuUIMessageTypes.ts", "../../packages/data-remote/src/server-proxy/server-proxy.ts", "../../packages/data-remote/src/worker.ts"],
  "sourcesContent": ["import { ServerToClientMessage, ClientToServerMessage } from '@vuu-ui/data-types';\nimport { Connection } from './connectionTypes';\n\nimport { ConnectionStatus, ConnectionStatusMessage } from './vuuUIMessageTypes';\n\nexport type ConnectionMessage = ServerToClientMessage | ConnectionStatusMessage;\nexport type ConnectionCallback = (msg: ConnectionMessage) => void;\n\n// TEST_DATA_COLLECTION\n// import { saveTestData } from './test-data-collection';\n\nconst logger = console;\n\nconst connectionAttempts: {\n  [key: string]: { attemptsRemaining: number; status: ConnectionStatus };\n} = {};\n\nconst setWebsocket = Symbol('setWebsocket');\nconst connectionCallback = Symbol('connectionCallback');\n\nexport async function connect(\n  connectionString: string,\n  callback: ConnectionCallback\n): Promise<Connection> {\n  return makeConnection(connectionString, callback);\n}\n\nasync function reconnect(connection: WebsocketConnection) {\n  //TODO it's not enough to reconnect with a new websocket, we have to log back in as well\n  makeConnection(connection.url, connection[connectionCallback], connection);\n}\n\nasync function makeConnection(\n  url: string,\n  callback: ConnectionCallback,\n  connection?: WebsocketConnection\n): Promise<Connection> {\n  const connectionStatus =\n    connectionAttempts[url] ||\n    (connectionAttempts[url] = {\n      attemptsRemaining: 5,\n      status: 'disconnected'\n    });\n\n  try {\n    callback({ type: 'connection-status', status: 'connecting' });\n    const reconnecting = typeof connection !== 'undefined';\n    const ws = await createWebsocket(url);\n\n    console.log(\n      `%c\u26A1 %c${url}`,\n      'font-size: 24px;color: green;font-weight: bold;',\n      'color:green; font-size: 14px;'\n    );\n\n    if (connection !== undefined) {\n      connection[setWebsocket](ws);\n    }\n\n    const websocketConnection = connection ?? new WebsocketConnection(ws, url, callback);\n\n    const status = reconnecting ? 'reconnected' : 'connected';\n    callback({ type: 'connection-status', status });\n    websocketConnection.status = status;\n\n    return websocketConnection as Connection;\n  } catch (evt) {\n    const retry = --connectionStatus.attemptsRemaining > 0;\n    callback({\n      type: 'connection-status',\n      status: 'disconnected',\n      reason: 'failed to connect',\n      retry\n    });\n    if (retry) {\n      return makeConnectionIn(url, callback, connection, 10000);\n    } else {\n      throw Error('Failed to establish connection');\n    }\n  }\n}\n\nconst makeConnectionIn = (\n  url: string,\n  callback: ConnectionCallback,\n  connection?: WebsocketConnection,\n  delay?: number\n): Promise<Connection> =>\n  new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(makeConnection(url, callback, connection));\n    }, delay);\n  });\n\nconst createWebsocket = (connectionString: string): Promise<WebSocket> =>\n  new Promise((resolve, reject) => {\n    //TODO add timeout\n    const ws = new WebSocket('ws://' + connectionString);\n    ws.onopen = () => resolve(ws);\n    ws.onerror = (evt) => reject(evt);\n  });\n\nconst closeWarn = () => {\n  logger.log(`Connection cannot be closed, socket not yet opened`);\n};\n\nconst sendWarn = (msg: ClientToServerMessage) => {\n  logger.log(`Message cannot be sent, socket closed: ${msg.body.type}`);\n};\n\nconst parseMessage = (message: string): ServerToClientMessage => {\n  try {\n    return JSON.parse(message) as ServerToClientMessage;\n  } catch (e) {\n    throw Error(`Error parsing JSON response from server ${message}`);\n  }\n};\n\nexport class WebsocketConnection implements Connection<ClientToServerMessage> {\n  [connectionCallback]: ConnectionCallback;\n  close: () => void = closeWarn;\n  requiresLogin = true;\n  send: (msg: ClientToServerMessage) => void = sendWarn;\n  status: 'closed' | 'ready' | 'connected' | 'reconnected' = 'ready';\n\n  private url: string;\n\n  constructor(ws: any, url: string, callback: ConnectionCallback) {\n    this.url = url;\n    this[connectionCallback] = callback;\n    this[setWebsocket](ws);\n  }\n\n  reconnect() {\n    reconnect(this);\n  }\n\n  [setWebsocket](ws: WebSocket) {\n    const callback = this[connectionCallback];\n\n    ws.onmessage = (evt) => {\n      // TEST DATA COLLECTION\n      // saveTestData(evt.data, 'server');\n      const vuuMessageFromServer = parseMessage(evt.data);\n      // console.log(\n      //   `%c<<< [${new Date().toISOString().slice(11, 23)}]  (WebSocket) ${message.body.type}\n      //   ${JSON.stringify(message)}\n      //   `,\n      //   'color:white;background-color:blue;font-weight:bold;'\n      // );\n      callback(vuuMessageFromServer);\n    };\n\n    ws.onerror = () => {\n      console.log(\n        `%c\u26A1 %c${this.url}`,\n        'font-size: 24px;color: red;font-weight: bold;',\n        'color:red; font-size: 14px;'\n      );\n      callback({\n        type: 'connection-status',\n        status: 'disconnected',\n        reason: 'error'\n      });\n      if (this.status !== 'closed') {\n        reconnect(this);\n        this.send = queue;\n      }\n    };\n\n    ws.onclose = () => {\n      console.log(\n        `%c\u26A1 %c${this.url}`,\n        'font-size: 24px;color: orange;font-weight: bold;',\n        'color:orange; font-size: 14px;'\n      );\n      callback({\n        type: 'connection-status',\n        status: 'disconnected',\n        reason: 'close'\n      });\n      if (this.status !== 'closed') {\n        reconnect(this);\n        this.send = queue;\n      }\n    };\n\n    const send = (msg: ClientToServerMessage) => {\n      // console.log(`%c>>>  (WebSocket) ${JSON.stringify(msg)}`, 'color:blue;font-weight:bold;');\n      ws.send(JSON.stringify(msg));\n    };\n\n    const queue = (msg: ClientToServerMessage) => {\n      console.log(`queuing message ${JSON.stringify(msg)} until websocket reconnected`);\n    };\n\n    this.send = send;\n\n    this.close = () => {\n      console.log('[Connection] close websocket');\n      this.status = 'closed';\n      ws.close();\n      this.close = closeWarn;\n      this.send = sendWarn;\n    };\n  }\n}\n", "export const AUTH = 'AUTH';\nexport const AUTH_SUCCESS = 'AUTH_SUCCESS';\nexport const CHANGE_VP = 'CHANGE_VP';\nexport const CHANGE_VP_SUCCESS = 'CHANGE_VP_SUCCESS';\nexport const CHANGE_VP_RANGE = 'CHANGE_VP_RANGE';\nexport const CHANGE_VP_RANGE_SUCCESS = 'CHANGE_VP_RANGE_SUCCESS';\nexport const CLOSE_TREE_NODE = 'CLOSE_TREE_NODE';\nexport const CLOSE_TREE_SUCCESS = 'CLOSE_TREE_SUCCESS';\nexport const CLOSE_TREE_REJECT = 'CLOSE_TREE_REJECT';\nexport const CREATE_VISUAL_LINK = 'CREATE_VISUAL_LINK';\nexport const CREATE_VISUAL_LINK_SUCCESS = 'CREATE_VISUAL_LINK_SUCCESS';\nexport const CREATE_VP = 'CREATE_VP';\nexport const CREATE_VP_SUCCESS = 'CREATE_VP_SUCCESS';\nexport const DISABLE_VP = 'DISABLE_VP';\nexport const DISABLE_VP_SUCCESS = 'DISABLE_VP_SUCCESS';\nexport const DISABLE_VP_REJECT = 'DISABLE_VP_REJECT';\nexport const ENABLE_VP = 'ENABLE_VP';\nexport const ENABLE_VP_SUCCESS = 'ENABLE_VP_SUCCESS';\nexport const ENABLE_VP_REJECT = 'ENABLE_VP_REJECT';\nexport const GET_TABLE_LIST = 'GET_TABLE_LIST';\nexport const GET_TABLE_META = 'GET_TABLE_META';\nexport const GET_VP_VISUAL_LINKS = 'GET_VP_VISUAL_LINKS';\nexport const GET_VIEW_PORT_MENUS = 'GET_VIEW_PORT_MENUS';\nexport const VIEW_PORT_MENUS_RESP = 'VIEW_PORT_MENUS_RESP';\nexport const VIEW_PORT_MENUS_SELECT_RPC = 'VIEW_PORT_MENUS_SELECT_RPC';\nexport const VIEW_PORT_MENU_CELL_RPC = 'VIEW_PORT_MENU_CELL_RPC';\nexport const VIEW_PORT_MENU_TABLE_RPC = 'VIEW_PORT_MENU_TABLE_RPC';\nexport const VIEW_PORT_MENU_ROW_RPC = 'VIEW_PORT_MENU_ROW_RPC';\nexport const VIEW_PORT_MENU_RESP = 'VIEW_PORT_MENU_RESP';\nexport const VIEW_PORT_MENU_REJ = 'VIEW_PORT_MENU_REJ';\nexport const HB = 'HB';\nexport const HB_RESP = 'HB_RESP';\nexport const LOGIN = 'LOGIN';\nexport const LOGIN_SUCCESS = 'LOGIN_SUCCESS';\nexport const OPEN_TREE_NODE = 'OPEN_TREE_NODE';\nexport const OPEN_TREE_SUCCESS = 'OPEN_TREE_SUCCESS';\nexport const OPEN_TREE_REJECT = 'OPEN_TREE_REJECT';\nexport const REMOVE_VP = 'REMOVE_VP';\nexport const REMOVE_VP_SUCCESS = 'REMOVE_VP_SUCCESS';\nexport const REMOVE_VP_REJECT = 'REMOVE_VP_REJECT';\nexport const RPC_CALL = 'RPC_CALL';\nexport const RPC_RESP = 'RPC_RESP';\nexport const MENU_RPC_CALL = 'MENU_RPC_CALL';\nexport const MENU_RPC_RESP = 'MENU_RPC_RESP';\nexport const SET_SELECTION = 'SET_SELECTION';\nexport const SET_SELECTION_SUCCESS = 'SET_SELECTION_SUCCESS';\nexport const TABLE_META_RESP = 'TABLE_META_RESP';\nexport const TABLE_LIST_RESP = 'TABLE_LIST_RESP';\nexport const VP_VISUAL_LINKS_RESP = 'VP_VISUAL_LINKS_RESP';\n\nexport const TABLE_ROW = 'TABLE_ROW';\nexport const SIZE = 'SIZE';\nexport const UPDATE = 'U';\n", "import { VuuRange } from '@vuu-ui/data-types';\n\nexport class KeySet {\n  private keys: Map<number, number>;\n  private free: number[];\n  private nextKeyValue: number;\n\n  constructor(range: VuuRange) {\n    this.keys = new Map();\n    this.free = [];\n    this.nextKeyValue = 0;\n    this.reset(range);\n  }\n\n  public next(): number {\n    if (this.free.length > 0) {\n      return this.free.pop() as number;\n    } else {\n      return this.nextKeyValue++;\n    }\n  }\n\n  public reset({ from, to }: VuuRange) {\n    this.keys.forEach((keyValue, rowIndex) => {\n      if (rowIndex < from || rowIndex >= to) {\n        this.free.push(keyValue);\n        this.keys.delete(rowIndex);\n      }\n    });\n\n    const size = to - from;\n    if (this.keys.size + this.free.length > size) {\n      this.free.length = size - this.keys.size;\n    }\n\n    for (let rowIndex = from; rowIndex < to; rowIndex++) {\n      if (!this.keys.has(rowIndex)) {\n        const nextKeyValue = this.next();\n        this.keys.set(rowIndex, nextKeyValue);\n      }\n    }\n  }\n\n  public keyFor(rowIndex: number): number {\n    const key = this.keys.get(rowIndex);\n    if (key === undefined) {\n      throw Error(`KeySet, no key found for rowIndex ${rowIndex}`);\n    }\n    return key;\n  }\n}\n", "const actionKeys = {\n  Enter: 'Enter',\n  Delete: 'Delete'\n};\n\nconst navigationKeys = {\n  Home: 'Home',\n  End: 'End',\n  ArrowRight: 'ArrowRight',\n  ArrowLeft: 'ArrowLeft',\n  ArrowDown: 'ArrowDown',\n  ArrowUp: 'ArrowUp',\n  Tab: 'Tab'\n};\nconst functionKeys = {\n  F1: 'F1',\n  F2: 'F2',\n  F3: 'F3',\n  F4: 'F4',\n  F5: 'F5',\n  F6: 'F6',\n  F7: 'F7',\n  F8: 'F8',\n  F9: 'F9',\n  F10: 'F10',\n  F11: 'F11',\n  F12: 'F12'\n};\n\nconst specialKeys = {\n  ...actionKeys,\n  ...navigationKeys,\n  ...functionKeys\n};\ntype specialKey = keyof typeof specialKeys;\n\nconst isSpecialKey = (key: string): key is specialKey => key in specialKeys;\n\nexport const isCharacterKey = (evt: KeyboardEvent) => {\n  if (isSpecialKey(evt.key)) {\n    return false;\n  }\n  if (typeof evt.which === 'number' && evt.which > 0) {\n    return !evt.ctrlKey && !evt.metaKey && !evt.altKey && evt.which !== 8;\n  }\n};\n\nexport const isQuoteKey = (evt: KeyboardEvent) => {\n  return evt.key === '\"' || evt.key === \"'\";\n};\n", "export interface VuuRange {\n  from: number;\n  to: number;\n  bufferSize?: number;\n  reset?: boolean;\n}\n\ninterface FromToRange {\n  from: number;\n  to: number;\n}\n\nexport function getFullRange(\n  { from, to }: VuuRange,\n  bufferSize: number = 0,\n  rowCount: number = Number.MAX_SAFE_INTEGER\n): FromToRange {\n  if (bufferSize === 0) {\n    return { from, to: Math.min(to, rowCount) };\n  } else if (from === 0) {\n    return { from, to: Math.min(to + bufferSize, rowCount) };\n  } else {\n    const rangeSize = to - from;\n    const buff = Math.round(bufferSize / 2);\n    const shortfallBefore = from - buff < 0;\n    const shortFallAfter = rowCount - (to + buff) < 0;\n\n    if (shortfallBefore && shortFallAfter) {\n      return { from: 0, to: rowCount };\n    } else if (shortfallBefore) {\n      return { from: 0, to: rangeSize + bufferSize };\n    } else if (shortFallAfter) {\n      return { from: Math.max(0, rowCount - (rangeSize + bufferSize)), to: rowCount };\n    } else {\n      return { from: from - buff, to: to + buff };\n    }\n  }\n}\n\nexport function resetRange({ from, to, bufferSize = 0 }: VuuRange): VuuRange {\n  return {\n    from: 0,\n    to: to - from,\n    bufferSize,\n    reset: true\n  };\n}\n\nexport class WindowRange {\n  public from: number;\n  public to: number;\n\n  constructor(from: number, to: number) {\n    this.from = from;\n    this.to = to;\n  }\n\n  public isWithin(index: number) {\n    return index >= this.from && index < this.to;\n  }\n\n  //find the overlap of this range and a new one\n  public overlap(from: number, to: number): [number, number] {\n    return from >= this.to || to < this.from\n      ? [0, 0]\n      : [Math.max(from, this.from), Math.min(to, this.to)];\n  }\n\n  public copy(): WindowRange {\n    return new WindowRange(this.from, this.to);\n  }\n}\n", "export interface FromToRange {\n  from: number;\n  to: number;\n}\n\nexport const bufferBreakout = (range: FromToRange, from: number, to: number, bufferSize: number): boolean => {\n  const bufferPerimeter = bufferSize * 0.25;\n  if (!range || !bufferSize) {\n    return true;\n  } else if (range.to - to < bufferPerimeter) {\n    return true;\n  } else if (range.from > 0 && from - range.from < bufferPerimeter) {\n    return true;\n  } else {\n    return false;\n  }\n};\n", "import { WindowRange } from '@vuu-ui/utils';\nimport { bufferBreakout } from './buffer-range';\nimport { VuuRange, VuuRow } from '@vuu-ui/data-types';\n\nconst EMPTY_ARRAY = [] as const;\n\ntype RangeTuple = [boolean, readonly VuuRow[], readonly VuuRow[]];\n\nexport class ArrayBackedMovingWindow {\n  private bufferSize: number;\n  private range: WindowRange;\n  private internalData: any[];\n  private rowsWithinRange: number;\n\n  public clientRange: WindowRange;\n  public rowCount: number;\n\n  // Note, the buffer is already accounted for in the range passed in here\n  constructor(\n    { from: clientFrom, to: clientTo }: VuuRange,\n    { from, to }: VuuRange,\n    bufferSize: number\n  ) {\n    this.bufferSize = bufferSize;\n    this.clientRange = new WindowRange(clientFrom, clientTo);\n    this.range = new WindowRange(from, to);\n    //internal data is always 0 based, we add range.from to determine an offset\n    this.internalData = new Array(bufferSize);\n    this.rowsWithinRange = 0;\n    this.rowCount = 0;\n  }\n\n  // TODO we shpuld probably have a hasAllClientRowsWithinRange\n  get hasAllRowsWithinRange(): boolean {\n    return (\n      this.rowsWithinRange === this.clientRange.to - this.clientRange.from ||\n      // this.rowsWithinRange === this.range.to - this.range.from ||\n      (this.rowCount > 0 && this.rowsWithinRange === this.rowCount)\n    );\n  }\n\n  setRowCount = (rowCount: number) => {\n    if (rowCount < this.internalData.length) {\n      this.internalData.length = rowCount;\n    }\n    if (rowCount < this.rowCount) {\n      // Brute force, works\n      this.rowsWithinRange = 0;\n      const end = Math.min(rowCount, this.clientRange.to);\n      for (let i = this.clientRange.from; i < end; i++) {\n        const rowIndex = i - this.range.from;\n        if (this.internalData[rowIndex] !== undefined) {\n          this.rowsWithinRange += 1;\n        }\n      }\n    }\n    this.rowCount = rowCount;\n  };\n\n  setAtIndex(index: number, data: any) {\n    const isWithinClientRange = this.isWithinClientRange(index);\n    if (isWithinClientRange || this.isWithinRange(index)) {\n      const internalIndex = index - this.range.from;\n      if (!this.internalData[internalIndex] && isWithinClientRange) {\n        this.rowsWithinRange += 1;\n        //onsole.log(`rowsWithinRange is now ${this.rowsWithinRange} out of ${this.range.to - this.range.from}`)\n      }\n      this.internalData[internalIndex] = data;\n    }\n    return isWithinClientRange;\n  }\n\n  getAtIndex(index: number): any {\n    return this.range.isWithin(index) && this.internalData[index - this.range.from] != null\n      ? this.internalData[index - this.range.from]\n      : undefined;\n  }\n\n  isWithinRange(index: number): boolean {\n    return this.range.isWithin(index);\n  }\n\n  isWithinClientRange(index: number): boolean {\n    return this.clientRange.isWithin(index);\n  }\n\n  // Returns [false] or [serverDataRequired, clientRows, holdingRows]\n  setClientRange(from: number, to: number): RangeTuple {\n    const currentFrom = this.clientRange.from;\n    const currentTo = Math.min(this.clientRange.to, this.rowCount);\n\n    if (from === currentFrom && to === currentTo) {\n      return [false, EMPTY_ARRAY, EMPTY_ARRAY] as RangeTuple;\n    }\n\n    const originalRange = this.clientRange.copy();\n    this.clientRange.from = from;\n    this.clientRange.to = to;\n    this.rowsWithinRange = 0;\n    for (let i = from; i < to; i++) {\n      const internalIndex = i - this.range.from;\n      if (this.internalData[internalIndex]) {\n        this.rowsWithinRange += 1;\n      }\n    }\n\n    let clientRows: readonly VuuRow[] = EMPTY_ARRAY;\n    let holdingRows: readonly VuuRow[] = EMPTY_ARRAY;\n    const offset = this.range.from;\n\n    if (this.hasAllRowsWithinRange) {\n      if (to > originalRange.to) {\n        const start = Math.max(from, originalRange.to);\n        clientRows = this.internalData.slice(start - offset, to - offset);\n      } else {\n        const end = Math.min(originalRange.from, to);\n        clientRows = this.internalData.slice(from - offset, end - offset);\n      }\n    } else if (this.rowsWithinRange > 0) {\n      if (to > originalRange.to) {\n        const start = Math.max(from, originalRange.to);\n        holdingRows = this.internalData.slice(start - offset, to - offset).filter((row) => !!row);\n      } else {\n        const end = Math.max(originalRange.from, to);\n        holdingRows = this.internalData\n          .slice(Math.max(0, from - offset), end - offset)\n          .filter((row) => !!row);\n      }\n    }\n\n    const serverDataRequired = bufferBreakout(this.range, from, to, this.bufferSize);\n    return [serverDataRequired, clientRows, holdingRows] as RangeTuple;\n  }\n\n  setRange(from: number, to: number) {\n    const [overlapFrom, overlapTo] = this.range.overlap(from, to);\n\n    const newData = new Array(to - from + this.bufferSize);\n    this.rowsWithinRange = 0;\n\n    for (let i = overlapFrom; i < overlapTo; i++) {\n      const data = this.getAtIndex(i);\n      if (data) {\n        const index = i - from;\n        newData[index] = data;\n        if (this.isWithinClientRange(i)) {\n          this.rowsWithinRange += 1;\n        }\n      }\n    }\n\n    this.internalData = newData;\n    this.range.from = from;\n    this.range.to = to;\n  }\n\n  getData(): any[] {\n    const { from, to } = this.range;\n    const { from: clientFrom, to: clientTo } = this.clientRange;\n    const startOffset = Math.max(0, clientFrom - from);\n    // TEMP hack, whu wouldn't we have rowCount ?\n    const endOffset = Math.min(to - from, to, clientTo - from, this.rowCount ?? to);\n    // const endOffset = Math.min(to-from, to, hi - from, this.rowCount);\n    return this.internalData.slice(startOffset, endOffset);\n  }\n}\n", "import { KeySet } from './keyset';\nimport * as Message from './messages';\nimport { ArrayBackedMovingWindow } from './array-backed-moving-window';\nimport { getFullRange } from '@vuu-ui/utils/src/range-utils';\nimport { bufferBreakout } from './buffer-range';\nimport {\n  ServerToClientCreateViewPortSuccess,\n  ClientToServerCreateLink,\n  ClientToServerCreateViewPort,\n  ClientToServerDisable,\n  ClientToServerEnable,\n  ClientToServerSelection,\n  ClientToServerViewPortRange,\n  VuuColumns,\n  VuuMenu,\n  VuuGroupBy,\n  VuuLink,\n  VuuRow,\n  VuuTable,\n  VuuAggregation,\n  VuuSortCol,\n  VuuRange\n} from '@vuu-ui/data-types';\nimport {\n  ServerProxySubscribeMessage,\n  VuuUIMessageInDisabled,\n  VuuUIMessageInEnabled,\n  VuuUIMessageInFilter,\n  VuuUIMessageInGroupBy,\n  VuuUIMessageInSubscribed,\n  VuuUIMessageInMenus,\n  VuuUIMessageInSort,\n  VuuUIMessageInViewPortVisualLinks,\n  VuuUIMessageInVisualLinkCreated,\n  VuuUIRow,\n  VuuUIRowPredicate\n} from '../vuuUIMessageTypes';\n\nconst EMPTY_ARRAY: unknown[] = [];\nconst EMPTY_GROUPBY: VuuGroupBy = [];\n\ninterface Disable {\n  type: 'disable';\n}\ninterface Enable {\n  type: 'enable';\n}\ninterface ChangeViewportRange {\n  type: 'CHANGE_VP_RANGE';\n}\ninterface Filter {\n  data: { filter: any; filterQuery: string };\n  type: 'filter';\n}\ninterface Aggregate {\n  data: VuuAggregation[];\n  type: 'aggregate';\n}\ninterface Selection {\n  data: number[];\n  type: 'selection';\n}\ninterface Sort {\n  data: VuuSortCol[];\n  type: 'sort';\n}\ninterface GroupBy {\n  data: VuuGroupBy;\n  type: 'groupBy';\n}\ninterface GroupByClear {\n  data: VuuGroupBy;\n  type: 'groupByClear';\n}\ntype CreateVisualLink = ClientToServerCreateLink;\n\ntype AsyncOperation =\n  | Aggregate\n  | ChangeViewportRange\n  | CreateVisualLink\n  | Disable\n  | Enable\n  | Filter\n  | GroupBy\n  | GroupByClear\n  | Selection\n  | Sort;\ntype RangeRequestTuple = [ClientToServerViewPortRange | null, VuuUIRow[]?];\ntype RowSortPredicate = (row1: VuuUIRow, row2: VuuUIRow) => number;\n\nconst byRowIndex: RowSortPredicate = ([index1], [index2]) => index1 - index2;\nexport class Viewport {\n  private aggregations: any;\n  private bufferSize: number;\n  private clientRange: VuuRange;\n  private columns: any[];\n  // TODO create this in constructor so we don't have to mark is as optional\n  private dataWindow?: ArrayBackedMovingWindow = undefined;\n  private disabled: boolean = false;\n  private filter: any;\n  private filterSpec: any;\n  private groupBy: any;\n  private hasUpdates: boolean = false;\n  private holdingPen: VuuUIRow[] = [];\n  private keys: any;\n  private lastTouchIdx: number | null = null;\n  private links: VuuLink[] = [];\n  private linkedParent: any = null;\n  private pendingLinkedParent: any;\n  private pendingOperations: any = new Map<string, AsyncOperation>();\n  private pendingRangeRequest: any = null;\n  private rowCountChanged: boolean = false;\n  private sort: any;\n\n  public clientViewportId: string;\n  public isTree: boolean = false;\n  public serverViewportId?: string;\n  public status: '' | 'subscribed' = '';\n  public suspended: boolean = false;\n  public table: VuuTable;\n\n  constructor({\n    viewport,\n    tablename,\n    aggregations,\n    columns,\n    range,\n    bufferSize = 50,\n    filter = '',\n    filterQuery = '',\n    sort = [],\n    groupBy = [],\n    visualLink\n  }: ServerProxySubscribeMessage) {\n    this.clientViewportId = viewport;\n    this.table = tablename;\n    this.aggregations = aggregations;\n    this.columns = columns;\n    this.clientRange = range;\n    this.bufferSize = bufferSize;\n    this.sort = {\n      sortDefs: sort\n    };\n    this.groupBy = groupBy;\n    this.filterSpec = {\n      filter: filterQuery\n    };\n    this.filter = filter;\n    this.keys = new KeySet(range);\n    this.pendingLinkedParent = visualLink;\n  }\n\n  get hasUpdatesToProcess() {\n    if (this.suspended) {\n      return false;\n    }\n    return this.rowCountChanged || this.hasUpdates;\n  }\n\n  subscribe() {\n    return {\n      type: Message.CREATE_VP,\n      table: this.table,\n      range: getFullRange(this.clientRange, this.bufferSize),\n      aggregations: this.aggregations,\n      columns: this.columns,\n      sort: this.sort,\n      groupBy: this.groupBy,\n      filterSpec: this.filterSpec\n    } as ClientToServerCreateViewPort;\n  }\n\n  handleSubscribed({\n    viewPortId,\n    aggregations,\n    columns,\n    range,\n    sort,\n    groupBy,\n    filterSpec\n  }: ServerToClientCreateViewPortSuccess) {\n    this.serverViewportId = viewPortId;\n    this.status = 'subscribed';\n    this.aggregations = aggregations;\n    this.columns = columns;\n    this.groupBy = groupBy;\n    this.filterSpec = filterSpec;\n    this.isTree = groupBy && groupBy.length > 0;\n    this.dataWindow = new ArrayBackedMovingWindow(this.clientRange, range, this.bufferSize);\n\n    console.log(\n      `%cViewport subscribed\n        clientVpId: ${this.clientViewportId}\n        serverVpId: ${this.serverViewportId}\n        table: ${this.table}\n        aggregations: ${JSON.stringify(aggregations)}\n        columns: ${columns.join(',')}\n        range: ${JSON.stringify(range)}\n        sort: ${JSON.stringify(sort)}\n        groupBy: ${JSON.stringify(groupBy)}\n        filterSpec: ${JSON.stringify(filterSpec)}\n        bufferSize: ${this.bufferSize}\n      `,\n      'color: blue'\n    );\n\n    return {\n      type: 'subscribed',\n      clientViewportId: this.clientViewportId,\n      columns,\n      filter: this.filter,\n      filterSpec: this.filterSpec\n    } as VuuUIMessageInSubscribed;\n  }\n\n  awaitOperation(requestId: string, msg: AsyncOperation) {\n    //TODO set uip a timeout mechanism here\n    this.pendingOperations.set(requestId, msg);\n  }\n\n  // Return a message if we need to communicate this to client UI\n  completeOperation(requestId: string, ...params: unknown[]) {\n    const { clientViewportId, pendingOperations } = this;\n    const { type, data } = pendingOperations.get(requestId);\n    pendingOperations.delete(requestId);\n    if (type === Message.CHANGE_VP_RANGE) {\n      const [from, to] = params as [number, number];\n      this.dataWindow?.setRange(from, to);\n      //this.hasUpdates = true; // is this right ??????????\n      this.pendingRangeRequest = null;\n    } else if (type === 'groupBy') {\n      this.isTree = true;\n      this.groupBy = data;\n      return { clientViewportId, type, groupBy: data } as VuuUIMessageInGroupBy;\n    } else if (type === 'groupByClear') {\n      this.isTree = false;\n      this.groupBy = [];\n      return { clientViewportId, type: 'groupBy', groupBy: null } as VuuUIMessageInGroupBy;\n    } else if (type === 'filter') {\n      this.filterSpec = { filter: data.filterQuery };\n      return { clientViewportId, type, ...data } as VuuUIMessageInFilter;\n    } else if (type === 'aggregate') {\n      this.aggregations = data;\n      return { clientViewportId, type, aggregations: data };\n    } else if (type === 'sort') {\n      this.sort = { sortDefs: data };\n      return { clientViewportId, type, sort: data } as VuuUIMessageInSort;\n    } else if (type === 'selection') {\n      // should we do this here ?\n      // this.selection = data;\n    } else if (type === 'disable') {\n      this.disabled = true; // assuming its _SUCCESS, of course\n      return {\n        type: 'disabled',\n        clientViewportId\n      } as VuuUIMessageInDisabled;\n    } else if (type === 'enable') {\n      this.disabled = false;\n      return {\n        type: 'enabled',\n        clientViewportId\n      } as VuuUIMessageInEnabled;\n    } else if (type === Message.CREATE_VISUAL_LINK) {\n      const [colName, parentViewportId, parentColName] = params;\n      this.linkedParent = {\n        colName,\n        parentViewportId,\n        parentColName\n      };\n      this.pendingLinkedParent = null;\n      return {\n        type: 'visual-link-created',\n        clientViewportId,\n        colName,\n        parentViewportId,\n        parentColName\n      } as VuuUIMessageInVisualLinkCreated;\n    }\n  }\n\n  rangeRequest(requestId: string, range: VuuRange): RangeRequestTuple {\n    // If we can satisfy the range request from the buffer, we will.\n    // May or may not need to make a server request, depending on status of buffer\n    const type = Message.CHANGE_VP_RANGE;\n    // If dataWindow has all data for the new range, it will return the\n    // delta of rows which are in the new range but were not in the\n    // previous range.\n    // Note: what if it doesn't have the entire range but DOES have all\n    // rows that constitute the delta ? Is this even possible ?\n\n    if (this.dataWindow) {\n      const [serverDataRequired, clientRows, holdingRows] = this.dataWindow.setClientRange(\n        range.from,\n        range.to\n      );\n      const serverRequest =\n        serverDataRequired &&\n        bufferBreakout(this.pendingRangeRequest, range.from, range.to, this.bufferSize)\n          ? ({\n              type,\n              viewPortId: this.serverViewportId,\n              ...getFullRange(range, this.bufferSize, this.dataWindow.rowCount)\n            } as ClientToServerViewPortRange)\n          : null;\n      if (serverRequest) {\n        // TODO check that there os not already a pending server request for more data\n        this.awaitOperation(requestId, { type });\n        this.pendingRangeRequest = serverRequest;\n      }\n\n      // always reset the keys here, even if we're not going to return rows immediately.\n      this.keys.reset(this.dataWindow.clientRange);\n\n      const rowWithinRange: VuuUIRowPredicate = ([index]) =>\n        index < range.from || index >= range.to;\n      if (this.holdingPen.some(rowWithinRange)) {\n        this.holdingPen = this.holdingPen.filter(\n          ([index]) => index >= range.from && index < range.to\n        );\n      }\n\n      const toClient = this.isTree ? toClientRowTree(this.groupBy, this.columns) : toClientRow;\n\n      if (holdingRows.length) {\n        holdingRows.forEach((row) => {\n          this.holdingPen.push(toClient(row, this.keys));\n        });\n      }\n\n      if (clientRows.length) {\n        return [\n          serverRequest,\n          clientRows.map((row) => {\n            return toClient(row, this.keys);\n          })\n        ];\n      } else {\n        return [serverRequest];\n      }\n    } else {\n      return [null];\n    }\n  }\n\n  setLinks(links: VuuLink[]) {\n    this.links = links;\n    return [\n      {\n        type: 'VP_VISUAL_LINKS_RESP',\n        links,\n        clientViewportId: this.clientViewportId\n      },\n      this.pendingLinkedParent\n    ] as [VuuUIMessageInViewPortVisualLinks, any];\n  }\n\n  setMenu(menu: VuuMenu) {\n    return {\n      type: 'VIEW_PORT_MENUS_RESP',\n      menu,\n      clientViewportId: this.clientViewportId\n    } as VuuUIMessageInMenus;\n  }\n\n  createLink(requestId: string, colName: string, parentVpId: string, parentColumnName: string) {\n    const message = {\n      type: Message.CREATE_VISUAL_LINK,\n      parentVpId,\n      childVpId: this.serverViewportId,\n      parentColumnName,\n      childColumnName: colName\n    } as CreateVisualLink;\n    this.awaitOperation(requestId, message);\n    return message as ClientToServerCreateLink;\n  }\n\n  suspend() {\n    this.suspended = true;\n  }\n\n  resume() {\n    this.suspended = false;\n    return this.currentData();\n  }\n\n  currentData() {\n    const out = [];\n    if (this.dataWindow) {\n      const records = this.dataWindow.getData();\n      const { keys } = this;\n      const toClient = this.isTree ? toClientRowTree(this.groupBy, this.columns) : toClientRow;\n      for (let row of records) {\n        if (row) {\n          out.push(toClient(row, keys));\n        }\n      }\n    }\n    return out;\n  }\n\n  enable(requestId: string) {\n    this.awaitOperation(requestId, { type: 'enable' });\n    return {\n      type: Message.ENABLE_VP,\n      viewPortId: this.serverViewportId\n    } as ClientToServerEnable;\n  }\n\n  disable(requestId: string) {\n    this.awaitOperation(requestId, { type: 'disable' });\n    return {\n      type: Message.DISABLE_VP,\n      viewPortId: this.serverViewportId\n    } as ClientToServerDisable;\n  }\n\n  filterRequest(requestId: string, filter: any, filterQuery: string) {\n    this.awaitOperation(requestId, { type: 'filter', data: { filter, filterQuery } });\n    return this.createRequest({ filterSpec: { filter: filterQuery } });\n  }\n\n  aggregateRequest(requestId: string, aggregations: VuuAggregation[]) {\n    this.awaitOperation(requestId, { type: 'aggregate', data: aggregations });\n    return this.createRequest({ aggregations });\n  }\n\n  sortRequest(requestId: string, sortCols: VuuSortCol[]) {\n    this.awaitOperation(requestId, { type: 'sort', data: sortCols });\n    return this.createRequest({ sort: { sortDefs: sortCols } });\n  }\n\n  groupByRequest(requestId: string, groupBy: VuuGroupBy = EMPTY_GROUPBY) {\n    const type = groupBy === EMPTY_ARRAY ? 'groupByClear' : 'groupBy';\n    this.awaitOperation(requestId, { type, data: groupBy });\n    return this.createRequest({ groupBy });\n  }\n\n  selectRequest(requestId: string, selection: number[]) {\n    // TODO we need to do this in the client if we are to raise selection events\n    // TODO is it right to set this here or should we wait for ACK from server ?\n    this.awaitOperation(requestId, { type: 'selection', data: selection });\n    return {\n      type: Message.SET_SELECTION,\n      vpId: this.serverViewportId,\n      selection\n    } as ClientToServerSelection;\n  }\n\n  handleUpdate(updateType: string, rowIndex: number, row: VuuRow) {\n    if (this.dataWindow) {\n      if (this.dataWindow.rowCount !== row.vpSize) {\n        this.dataWindow.setRowCount(row.vpSize);\n        this.rowCountChanged = true;\n      }\n      if (updateType === 'U') {\n        // Update will return true if row was within client range\n        if (this.dataWindow.setAtIndex(rowIndex, row)) {\n          this.hasUpdates = true;\n        }\n      }\n    }\n  }\n\n  getNewRowCount = () => {\n    if (this.rowCountChanged && this.dataWindow) {\n      this.rowCountChanged = false;\n      return this.dataWindow.rowCount;\n    }\n  };\n\n  // This is called only after new data has been received from server - data\n  // returned direcly from buffer does not use this.\n  // If we have updates, but we don't yet have data for the full client range\n  // in our buffer, store them in the holding pen. We know the remaining rows\n  // have been requested and will arrive imminently. Soon as we receive data,\n  // contents of holding pen plus additional rows received that fill the range\n  // will be dispatched to client.\n  // If we have any rows in the holding pen, and we now have a full set of\n  // client data, make sure we empty the pen and send those rows to client,\n  // along qith the new data.\n  // TODO what if we're going backwards\n  getClientRows(timeStamp: number) {\n    if (this.hasUpdates && this.dataWindow) {\n      const records = this.dataWindow.getData();\n      const { keys } = this;\n      const toClient = this.isTree ? toClientRowTree(this.groupBy, this.columns) : toClientRow;\n\n      // NOte this should probably just check that we havs all client rows within range ?\n      const clientRows = this.dataWindow.hasAllRowsWithinRange\n        ? this.holdingPen.splice(0)\n        : undefined;\n\n      const out = clientRows || this.holdingPen;\n\n      for (let row of records) {\n        if (row && row.ts >= timeStamp) {\n          out.push(toClient(row, keys));\n        }\n      }\n      this.hasUpdates = false;\n\n      // this only matters where we scroll backwards and have holdingPen data\n      // should we test for that explicitly ?\n      return clientRows && clientRows.sort(byRowIndex);\n    }\n  }\n\n  createRequest(params: any) {\n    return {\n      type: Message.CHANGE_VP,\n      viewPortId: this.serverViewportId,\n      aggregations: this.aggregations,\n      columns: this.columns,\n      sort: this.sort,\n      groupBy: this.groupBy,\n      filterSpec: this.filterSpec,\n      ...params\n    };\n  }\n}\n\nconst toClientRow = ({ rowIndex, rowKey, sel: isSelected, data }: VuuRow, keys: KeySet) =>\n  [rowIndex, keys.keyFor(rowIndex), true, null, null, 1, rowKey, isSelected].concat(\n    data\n  ) as VuuUIRow;\n\nconst toClientRowTree =\n  (groupBy: VuuGroupBy, columns: VuuColumns) =>\n  ({ rowIndex, rowKey, sel: isSelected, data }: VuuRow, keys: KeySet) => {\n    let [depth, isExpanded /* path */, , isLeaf /* label */, , count, ...rest] = data;\n\n    // TODO do we need this - the data is already there\n    const steps = rowKey.split('|').slice(1);\n    groupBy.forEach((col, i) => {\n      const idx = columns.indexOf(col);\n      rest[idx] = steps[i];\n    });\n\n    const record = [\n      rowIndex,\n      keys.keyFor(rowIndex),\n      isLeaf,\n      isExpanded,\n      depth,\n      count,\n      rowKey,\n      isSelected\n    ].concat(rest);\n\n    return record as VuuUIRow;\n  };\n", "export const getRpcService = (method) => {\n  switch (method) {\n    case 'getUniqueFieldValues':\n      return ['TypeAheadRpcHandler', 'TYPEAHEAD'];\n    default:\n      return ['OrderEntryRpcHandler', 'SIMUL'];\n  }\n};\n", "import { msgType } from './constants';\nimport {\n  VuuAggregation,\n  VuuColumns,\n  VuuFilter,\n  VuuGroupBy,\n  VuuLink,\n  VuuMenu,\n  VuuMenuContext,\n  VuuRange,\n  VuuSort,\n  VuuSortCol,\n  VuuTable\n} from '@vuu-ui/data-types';\n\nexport type ConnectionStatus = 'connecting' | 'connected' | 'disconnected' | 'reconnected';\n\nexport interface ConnectionStatusMessage {\n  type: 'connection-status';\n  reason?: string;\n  retry?: boolean;\n  status: ConnectionStatus;\n}\n\nexport const isConnectionStatusMessage = (msg: object): msg is ConnectionStatusMessage =>\n  (msg as ConnectionStatusMessage).type === 'connection-status';\n\nexport type VuuUIRow = [number, string, boolean, any, any, number, string, boolean, ...any[]];\n\nexport type VuuUIRowPredicate = (row: VuuUIRow) => boolean;\n\nexport interface ServerProxySubscribeMessage {\n  aggregations: any;\n  bufferSize?: number;\n  columns: VuuColumns;\n  filter: any;\n  filterQuery: any;\n  groupBy: any;\n  range: VuuRange;\n  sort: any;\n  tablename: VuuTable;\n  viewport: string;\n  visualLink: any;\n}\n\n// export type VuuUIMessageInConnectionStatus = {\n//   type: 'connection-status';\n// };\n\nexport type VuuUIMessageInConnected = {\n  type: 'connected';\n};\n\nexport type VuuUIMessageInWorkerReady = {\n  type: 'ready';\n};\n\nexport interface ViewportMessage {\n  clientViewportId: string;\n}\n\nexport interface VuuUIMessageInDisabled extends ViewportMessage {\n  type: 'disabled';\n}\nexport interface VuuUIMessageInEnabled extends ViewportMessage {\n  type: 'enabled';\n}\n\nexport interface VuuUIMessageInSubscribed extends ViewportMessage {\n  aggregations: VuuAggregation[];\n  columns: VuuColumns;\n  filter: any;\n  filterSpec: VuuFilter;\n  groupBy: VuuGroupBy;\n  range: VuuRange;\n  type: 'subscribed';\n}\n\nexport interface VuuUIMessageInFilter extends ViewportMessage {\n  type: 'filter';\n  filter: any;\n  filterQuery: any;\n}\n\nexport interface VuuUIMessageInGroupBy extends ViewportMessage {\n  type: 'groupBy';\n  groupBy: VuuGroupBy | null;\n}\nexport interface VuuUIMessageInSort extends ViewportMessage {\n  type: 'sort';\n  sort: VuuSort;\n}\n\nexport type VuuUIMessageInViewportUpdates = {\n  type: 'viewport-updates';\n  viewports: {\n    [viewport: string]: {\n      rows?: VuuUIRow[];\n      size?: number;\n    };\n  };\n};\n\nexport type VuuUIMessageInViewportUpdate = {\n  type: 'viewport-update';\n  rows: VuuUIRow[];\n  size: number;\n};\n\nexport interface VuuUIMessageInRPC {\n  method: string;\n  result: any;\n  requestId: string;\n  type: 'RPC_RESP';\n}\n\nexport interface VuuUIMessageInTableList {\n  requestId: string;\n  type: 'TABLE_LIST_RESP';\n  tables: VuuTable[];\n}\nexport interface VuuUIMessageInTableMeta {\n  columns: string[];\n  dataTypes: string[];\n  requestId: string;\n  table: VuuTable;\n  type: 'TABLE_META_RESP';\n}\nexport interface VuuUIMessageInViewPortVisualLinks {\n  type: 'VP_VISUAL_LINKS_RESP';\n  links: VuuLink[];\n  clientViewportId: string;\n}\nexport interface VuuUIMessageInVisualLinkCreated {\n  clientViewportId: string;\n  colName: string;\n  parentViewportId: string;\n  parentColName: string;\n  type: 'visual-link-created';\n}\nexport interface VuuUIMessageInMenus {\n  type: 'VIEW_PORT_MENUS_RESP';\n  menu: VuuMenu;\n  clientViewportId: string;\n}\nexport interface VuuUIMessageInMenu {\n  action: {\n    table: VuuTable;\n  };\n  requestId: string;\n  tableAlreadyOpen?: boolean;\n  type: 'VIEW_PORT_MENU_RESP';\n}\n\nexport type VuuUIMessageIn =\n  | VuuUIMessageInDisabled\n  | VuuUIMessageInEnabled\n  | VuuUIMessageInConnected\n  // | VuuUIMessageInConnectionStatus\n  | VuuUIMessageInWorkerReady\n  | VuuUIMessageInFilter\n  | VuuUIMessageInGroupBy\n  | VuuUIMessageInSubscribed\n  | VuuUIMessageInViewportUpdate\n  | VuuUIMessageInViewportUpdates\n  | VuuUIMessageInRPC\n  | VuuUIMessageInMenu\n  | VuuUIMessageInMenus\n  | VuuUIMessageInSort\n  | VuuUIMessageInViewPortVisualLinks\n  | VuuUIMessageInVisualLinkCreated\n  | VuuUIMessageInTableList\n  | VuuUIMessageInTableMeta;\n\nexport interface VuuUIMessageOutConnect {\n  type: 'connect';\n  token: string;\n  url: string;\n  useWebsocket: boolean;\n}\n\nexport interface VuuUIMessageOutSubscribe extends ServerProxySubscribeMessage {\n  type: 'subscribe';\n}\n\nexport interface VuuUIMessageOutUnsubscribe {\n  type: 'unsubscribe';\n  viewport: string;\n}\n\nexport interface ViewportMessage {\n  viewport: string;\n}\n\nexport interface RequestMessage {\n  requestId: string;\n}\n\nexport interface VuuUIMessageOutViewRange extends ViewportMessage {\n  type: 'setViewRange';\n  range: {\n    from: number;\n    to: number;\n  };\n}\nexport interface VuuUIMessageOutAggregate extends ViewportMessage {\n  aggregations: VuuAggregation[];\n  type: 'aggregate';\n}\nexport interface VuuUIMessageOutCloseTreeNode extends ViewportMessage {\n  key: string;\n  type: 'closeTreeNode';\n}\nexport interface VuuUIMessageOutCreateLink extends ViewportMessage {\n  childColumnName: string;\n  parentColumnName: string;\n  parentVpId: string;\n  type: 'createLink';\n}\n\nexport interface VuuUIMessageOutDisable extends ViewportMessage {\n  type: 'disable';\n}\nexport interface VuuUIMessageOutEnable extends ViewportMessage {\n  type: 'enable';\n}\nexport interface VuuUIMessageOutOpenTreeNode extends ViewportMessage {\n  key: string;\n  type: 'openTreeNode';\n}\nexport interface VuuUIMessageOutResume extends ViewportMessage {\n  type: 'resume';\n}\n\nexport interface VuuUIMessageOutSelect extends ViewportMessage {\n  selected: number[];\n  type: 'select';\n}\n\nexport interface VuuUIMessageOutSort extends ViewportMessage {\n  sortCriteria: VuuSortCol[];\n  type: 'sort';\n}\nexport interface VuuUIMessageOutSuspend extends ViewportMessage {\n  type: 'suspend';\n}\n\nexport interface VuuUIMessageOutFilterQuery extends ViewportMessage {\n  filter: any;\n  filterQuery: string;\n  type: 'filterQuery';\n}\nexport interface VuuUIMessageOutGroupby extends ViewportMessage {\n  groupBy: any[];\n  type: 'groupBy';\n}\n\nexport interface VuuUIMessageOutMenuRPC extends RequestMessage, ViewportMessage {\n  context: VuuMenuContext;\n  rpcName: string;\n  type: 'MENU_RPC_CALL';\n}\n\nexport type VuuUIMessageOutViewport =\n  | VuuUIMessageOutAggregate\n  | VuuUIMessageOutCloseTreeNode\n  | VuuUIMessageOutCreateLink\n  | VuuUIMessageOutFilterQuery\n  | VuuUIMessageOutDisable\n  | VuuUIMessageOutEnable\n  | VuuUIMessageOutGroupby\n  | VuuUIMessageOutOpenTreeNode\n  | VuuUIMessageOutResume\n  | VuuUIMessageOutSelect\n  | VuuUIMessageOutSuspend\n  | VuuUIMessageOutSort\n  | VuuUIMessageOutViewRange\n  | VuuUIMessageOutMenuRPC;\n\nexport const isViewporttMessage = (msg: object): msg is VuuUIMessageOutViewport =>\n  'viewport' in msg;\n\nexport interface VuuUIMessageOutRPC extends RequestMessage {\n  method: string;\n  params: any[];\n  type: 'RPC_CALL';\n}\n\nexport type VuuUIMessageOutRpcCall = VuuUIMessageOutRPC | VuuUIMessageOutMenuRPC;\n\nexport interface VuuUIMessageOutTableList extends RequestMessage {\n  type: 'GET_TABLE_LIST';\n}\n\nexport interface VuuUIMessageOutTableMeta extends RequestMessage {\n  type: 'GET_TABLE_META';\n  table: VuuTable;\n}\n\nexport type VuuUIMessageOutAsyncRequest = VuuUIMessageOutTableList | VuuUIMessageOutTableMeta;\n\nexport const isAsyncRequestMessage = (msg: object): msg is VuuUIMessageOutAsyncRequest =>\n  'requestId' in msgType;\n\nexport type VuuUIMessageOut =\n  | VuuUIMessageOutConnect\n  | VuuUIMessageOutSubscribe\n  | VuuUIMessageOutUnsubscribe\n  | VuuUIMessageOutAsyncRequest\n  | VuuUIMessageOutViewport\n  | VuuUIMessageOutRpcCall;\n\nexport type RpcRequest = {};\nexport type RpcResponse = {};\n\nexport type TableMeta = {};\nexport type TableList = {};\n\n// These are the messages sent to the client data source\nexport type ClientViewportMessage = {};\n", "import * as Message from './messages';\nimport { Viewport } from './viewport';\nimport { getRpcService } from './rpc-services';\nimport { Connection } from '../connectionTypes';\nimport {\n  ServerToClientMessage,\n  ClientToServerMessage,\n  VuuLink,\n  VuuMenuContext,\n  VuuTable\n} from '@vuu-ui/data-types';\nimport {\n  isViewporttMessage as isViewportMessage,\n  ServerProxySubscribeMessage,\n  VuuUIMessageIn,\n  VuuUIMessageInTableList,\n  VuuUIMessageInTableMeta,\n  VuuUIMessageInViewportUpdates,\n  VuuUIMessageOut,\n  VuuUIMessageOutAggregate,\n  VuuUIMessageOutConnect,\n  VuuUIMessageOutCreateLink,\n  VuuUIMessageOutDisable,\n  VuuUIMessageOutEnable,\n  VuuUIMessageOutFilterQuery,\n  VuuUIMessageOutGroupby,\n  VuuUIMessageOutMenuRPC,\n  VuuUIMessageOutRPC,\n  VuuUIMessageOutOpenTreeNode,\n  VuuUIMessageOutCloseTreeNode,\n  VuuUIMessageOutSelect,\n  VuuUIMessageOutSort,\n  VuuUIMessageOutSubscribe,\n  VuuUIMessageOutUnsubscribe,\n  VuuUIMessageOutViewRange\n} from '../vuuUIMessageTypes';\n\nexport type PostMessageToClientCallback = (message: VuuUIMessageIn) => void;\n\n// TEST_DATA_COLLECTION\n// import { saveTestData } from '../../test-data-collection';\n\nlet _requestId: number = 1;\nexport const TEST_setRequestId = (id: number) => (_requestId = id);\n\nconst nextRequestId = () => `${_requestId++}`;\nconst EMPTY_ARRAY: unknown[] = [];\nconst DEFAULT_OPTIONS = {};\n\nconst getRPCType = (\n  msgType: 'MENU_RPC_CALL',\n  context: VuuMenuContext\n): 'VIEW_PORT_MENUS_SELECT_RPC' => {\n  if (msgType === 'MENU_RPC_CALL' && context === 'selected-rows') {\n    return 'VIEW_PORT_MENUS_SELECT_RPC';\n  } else {\n    throw Error('No RPC command for ${msgType} / ${context}');\n  }\n};\n\ninterface PendingLogin {\n  resolve: (value: any) => void; // TODO\n  reject: () => void;\n}\nexport class ServerProxy {\n  private connection: Connection;\n  private postMessageToClient: PostMessageToClientCallback;\n  private viewports: Map<string, Viewport>;\n  private mapClientToServerViewport: Map<string, string>;\n  private authToken?: string;\n  private pendingLogin?: PendingLogin;\n  private sessionId?: string;\n  private queuedRequests: Array<ClientToServerMessage['body']> = [];\n\n  constructor(connection: Connection, callback: PostMessageToClientCallback) {\n    this.connection = connection;\n    this.postMessageToClient = callback;\n    this.viewports = new Map<string, Viewport>();\n    this.mapClientToServerViewport = new Map();\n  }\n\n  public async login(authToken?: string) {\n    if (authToken) {\n      this.authToken = authToken;\n    }\n    const token = this.authToken;\n    if (token === undefined) {\n      throw Error(`ServerProxy login, cannot login until auth token has been obtained`);\n    }\n    return new Promise((resolve, reject) => {\n      this.sendMessageToServer({ type: Message.LOGIN, token, user: 'user' }, '');\n      this.pendingLogin = { resolve, reject };\n    });\n  }\n\n  public subscribe(message: ServerProxySubscribeMessage) {\n    // guard against subscribe message when a viewport is already subscribed\n    if (!this.mapClientToServerViewport.has(message.viewport)) {\n      const viewport = new Viewport(message);\n      this.viewports.set(message.viewport, viewport);\n      // use client side viewport as request id, so that when we process the response,\n      // with the serverside viewport we can establish a mapping between the two\n      this.sendIfReady(viewport.subscribe(), message.viewport, this.sessionId !== '');\n    } else {\n      console.log(`ServerProxy spurious subscribe call ${message.viewport}`);\n    }\n  }\n\n  public unsubscribe(clientViewportId: string) {\n    const serverViewportId = this.mapClientToServerViewport.get(clientViewportId);\n    if (serverViewportId) {\n      this.sendMessageToServer({\n        type: Message.REMOVE_VP,\n        viewPortId: serverViewportId\n      });\n    } else {\n      console.error(`ServerProxy: failed to unsubscribe client viewport ${clientViewportId}`);\n    }\n  }\n\n  private getViewportForClient(clientViewportId: string): Viewport {\n    const serverViewportId = this.mapClientToServerViewport.get(clientViewportId);\n    if (serverViewportId) {\n      const viewport = this.viewports.get(serverViewportId);\n      if (viewport) {\n        return viewport;\n      } else {\n        throw Error(`Viewport not found for client viewport ${clientViewportId}`);\n      }\n    } else {\n      throw Error(`Viewport server id not found for client viewport ${clientViewportId}`);\n    }\n  }\n\n  /**********************************************************************/\n  /* Handle messages from client                                        */\n  /**********************************************************************/\n  private setViewRange(viewport: Viewport, message: VuuUIMessageOutViewRange) {\n    const requestId = nextRequestId();\n    const [serverRequest, rows] = viewport.rangeRequest(requestId, message.range);\n    if (serverRequest) {\n      this.sendIfReady(serverRequest, requestId, viewport.status === 'subscribed');\n    }\n    if (rows) {\n      this.postMessageToClient({\n        type: 'viewport-updates',\n        viewports: {\n          [viewport.clientViewportId]: { rows }\n        }\n      });\n    }\n  }\n\n  private aggregate(viewport: Viewport, message: VuuUIMessageOutAggregate) {\n    const requestId = nextRequestId();\n    const request = viewport.aggregateRequest(requestId, message.aggregations);\n    this.sendIfReady(request, requestId, viewport.status === 'subscribed');\n  }\n\n  private sort(viewport: Viewport, message: VuuUIMessageOutSort) {\n    const requestId = nextRequestId();\n    const request = viewport.sortRequest(requestId, message.sortCriteria);\n    this.sendIfReady(request, requestId, viewport.status === 'subscribed');\n  }\n\n  private groupBy(viewport: Viewport, message: VuuUIMessageOutGroupby) {\n    const requestId = nextRequestId();\n    const request = viewport.groupByRequest(requestId, message.groupBy);\n    this.sendIfReady(request, requestId, viewport.status === 'subscribed');\n  }\n\n  private filter(viewport: Viewport, message: VuuUIMessageOutFilterQuery) {\n    const requestId = nextRequestId();\n    const { filter, filterQuery } = message;\n    const request = viewport.filterRequest(requestId, filter, filterQuery);\n    this.sendIfReady(request, requestId, viewport.status === 'subscribed');\n  }\n\n  private select(viewport: Viewport, message: VuuUIMessageOutSelect) {\n    const requestId = nextRequestId();\n    const { selected } = message;\n    const request = viewport.selectRequest(requestId, selected);\n    this.sendIfReady(request, requestId, viewport.status === 'subscribed');\n  }\n\n  //TODO when do we ever checj the disabled state ?\n  private disableViewport(viewport: Viewport, message: VuuUIMessageOutDisable) {\n    const requestId = nextRequestId();\n    const request = viewport.disable(requestId);\n    this.sendIfReady(request, requestId, viewport.status === 'subscribed');\n  }\n\n  private enableViewport(viewport: Viewport, message: VuuUIMessageOutEnable) {\n    const requestId = nextRequestId();\n    const request = viewport.enable(requestId);\n    this.sendIfReady(request, requestId, viewport.status === 'subscribed');\n  }\n\n  private resumeViewport(viewport: Viewport) {\n    const rows = viewport.resume();\n    this.postMessageToClient({\n      type: 'viewport-updates',\n      viewports: {\n        [viewport.clientViewportId]: { rows }\n      }\n    });\n  }\n\n  private openTreeNode(viewport: Viewport, message: VuuUIMessageOutOpenTreeNode) {\n    if (viewport.serverViewportId) {\n      this.sendIfReady(\n        {\n          type: Message.OPEN_TREE_NODE,\n          vpId: viewport.serverViewportId,\n          treeKey: message.key\n        },\n        nextRequestId(),\n        viewport.status === 'subscribed'\n      );\n    }\n  }\n\n  private closeTreeNode(viewport: Viewport, message: VuuUIMessageOutCloseTreeNode) {\n    if (viewport.serverViewportId) {\n      this.sendIfReady(\n        {\n          type: Message.CLOSE_TREE_NODE,\n          vpId: viewport.serverViewportId,\n          treeKey: message.key\n        },\n        nextRequestId(),\n        viewport.status === 'subscribed'\n      );\n    }\n  }\n\n  private createLink(viewport: Viewport, message: VuuUIMessageOutCreateLink) {\n    const { parentVpId, parentColumnName, childColumnName } = message;\n    const requestId = nextRequestId();\n    const request = viewport.createLink(requestId, childColumnName, parentVpId, parentColumnName);\n    this.sendMessageToServer(request, requestId);\n  }\n\n  private menuRpcCall(viewport: Viewport, message: VuuUIMessageOutMenuRPC) {\n    if (viewport.serverViewportId) {\n      const { context, rpcName } = message;\n      this.sendMessageToServer(\n        {\n          type: getRPCType(message.type, context),\n          rpcName,\n          vpId: viewport.serverViewportId\n        },\n        message.requestId\n      );\n    }\n  }\n\n  private rpcCall(message: VuuUIMessageOutRPC) {\n    // below duplicated - tidy up\n    const { method, requestId, type } = message;\n    const [service, module] = getRpcService(method);\n    this.sendMessageToServer(\n      {\n        type,\n        service,\n        method,\n        params: message.params /*|| [viewport.serverViewportId]*/,\n        namedParams: {}\n      },\n      requestId,\n      { module }\n    );\n  }\n\n  public handleMessageFromClient(\n    message: Exclude<\n      VuuUIMessageOut,\n      VuuUIMessageOutConnect | VuuUIMessageOutSubscribe | VuuUIMessageOutUnsubscribe\n    >\n  ) {\n    if (isViewportMessage(message)) {\n      const viewport = this.getViewportForClient(message.viewport);\n      switch (message.type) {\n        case 'setViewRange':\n          return this.setViewRange(viewport, message);\n        case 'aggregate':\n          return this.aggregate(viewport, message);\n        case 'sort':\n          return this.sort(viewport, message);\n        case 'groupBy':\n          return this.groupBy(viewport, message);\n        case 'filterQuery':\n          return this.filter(viewport, message);\n        case 'select':\n          return this.select(viewport, message);\n        case 'suspend':\n          return viewport.suspend();\n        case 'resume':\n          return this.resumeViewport(viewport);\n        case 'disable':\n          return this.disableViewport(viewport, message);\n        case 'enable':\n          return this.enableViewport(viewport, message);\n        case 'openTreeNode':\n          return this.openTreeNode(viewport, message);\n        case 'closeTreeNode':\n          return this.closeTreeNode(viewport, message);\n        case 'createLink':\n          return this.createLink(viewport, message);\n        case 'MENU_RPC_CALL':\n          return this.menuRpcCall(viewport, message);\n        default:\n      }\n    } else {\n      const { type, requestId } = message;\n      switch (type) {\n        case Message.GET_TABLE_LIST:\n          return this.sendMessageToServer({ type }, requestId);\n        case Message.GET_TABLE_META:\n          return this.sendMessageToServer({ type, table: message.table }, requestId);\n        case Message.RPC_CALL:\n          return this.rpcCall(message);\n        default:\n      }\n    }\n    console.log(`Vuu ServerProxy Unexpected message from client ${JSON.stringify(message)}`);\n    // TEST DATA COLLECTION\n    // saveTestData(message, 'client');\n    //---------------------\n  }\n\n  public sendIfReady(\n    message: ClientToServerMessage['body'],\n    requestId: string,\n    isReady: boolean = true,\n    options?: any\n  ) {\n    // TODO implement the message queuing in remote data view\n    if (isReady) {\n      this.sendMessageToServer(message, requestId, options);\n    } else {\n      // TODO need to make sure we keep the requestId\n      this.queuedRequests.push(message);\n    }\n    return isReady;\n  }\n\n  public sendMessageToServer(\n    body: ClientToServerMessage['body'],\n    requestId: string = `${_requestId++}`,\n    options: any = DEFAULT_OPTIONS\n  ) {\n    const { module = 'CORE', ...restOptions } = options;\n    // const { clientId } = this.connection;\n    if (this.authToken) {\n      this.connection.send(\n        {\n          requestId,\n          sessionId: this.sessionId,\n          token: this.authToken,\n          user: 'user',\n          module,\n          body\n        } as ClientToServerMessage\n        // restOptions\n      );\n    }\n  }\n\n  public handleMessageFromServer(message: ServerToClientMessage) {\n    const { body, requestId, sessionId } = message;\n\n    // onsole.log(`%c<<< [${new Date().toISOString().slice(11,23)}]  (ServerProxy) ${message.type || JSON.stringify(message)}`,'color:white;background-color:blue;font-weight:bold;');\n\n    const { viewports } = this;\n    switch (body.type) {\n      case Message.HB:\n        this.sendMessageToServer({ type: Message.HB_RESP, ts: +new Date() }, 'NA');\n        break;\n\n      case Message.LOGIN_SUCCESS:\n        this.sessionId = sessionId;\n        this.pendingLogin?.resolve(sessionId);\n        break;\n\n      case Message.CREATE_VP_SUCCESS:\n        {\n          const viewport = viewports.get(requestId);\n          // The clientViewportId was used as requestId for CREATE_VP message\n          if (viewport) {\n            const { viewPortId: serverViewportId } = body;\n\n            if (requestId !== serverViewportId) {\n              viewports.delete(requestId);\n              viewports.set(serverViewportId, viewport);\n            }\n            this.mapClientToServerViewport.set(requestId, serverViewportId);\n            const response = viewport.handleSubscribed(body);\n            if (response) {\n              this.postMessageToClient(response);\n            }\n            this.sendMessageToServer({ type: Message.GET_VP_VISUAL_LINKS, vpId: serverViewportId });\n            this.sendMessageToServer({ type: Message.GET_VIEW_PORT_MENUS, vpId: serverViewportId });\n          }\n        }\n        break;\n\n      case Message.REMOVE_VP_SUCCESS:\n        {\n          const viewport = this.viewports.get(body.viewPortId);\n          if (viewport) {\n            // do we need a destroy method on viewport for cleanup ?\n            this.mapClientToServerViewport.delete(viewport.clientViewportId);\n            viewports.delete(body.viewPortId);\n          }\n        }\n        break;\n\n      case Message.SET_SELECTION_SUCCESS:\n        const viewport = this.viewports.get(body.vpId);\n        if (viewport) {\n          viewport.completeOperation(requestId);\n        }\n        break;\n\n      case Message.CHANGE_VP_SUCCESS:\n      case Message.DISABLE_VP_SUCCESS:\n        if (viewports.has(body.viewPortId)) {\n          const viewport = this.viewports.get(body.viewPortId);\n          if (viewport) {\n            const response = viewport.completeOperation(requestId);\n            if (response) {\n              this.postMessageToClient(response);\n            }\n          }\n        }\n\n        break;\n\n      case Message.ENABLE_VP_SUCCESS:\n        {\n          const viewport = this.viewports.get(body.viewPortId);\n          if (viewport) {\n            const response = viewport.completeOperation(requestId);\n            if (response) {\n              this.postMessageToClient(response);\n              const rows = viewport.currentData();\n              const clientMessage = {\n                type: 'viewport-updates',\n                viewports: {\n                  [viewport.clientViewportId]: { rows }\n                }\n              } as VuuUIMessageInViewportUpdates;\n              this.postMessageToClient(clientMessage);\n            }\n          }\n        }\n        break;\n      case Message.TABLE_ROW:\n        {\n          const { timeStamp } = body;\n          const [{ ts: firstBatchTimestamp } = { ts: timeStamp }] = body.rows || EMPTY_ARRAY;\n          // onsole.log(`\\nbatch timestamp ${time(timeStamp)} first timestamp ${time(firstBatchTimestamp)} ${body.rows.length} rows in batch`)\n          for (const row of body.rows) {\n            const { viewPortId, rowIndex, rowKey, updateType } = row;\n            const viewport = viewports.get(viewPortId);\n            if (viewport) {\n              // onsole.log(`row timestamp ${time(row.ts)}`)\n              // This might miss rows if we receive rows after submitting a groupByRequest but before\n              // receiving the ACK\n              if (viewport.isTree && updateType === 'U' && !rowKey.startsWith('$root')) {\n                console.log('Ignore blank rows sent after GroupBy');\n              } else {\n                viewport.handleUpdate(updateType, rowIndex, row);\n              }\n            } else {\n              console.warn(`TABLE_ROW message received for non registered viewport ${viewPortId}`);\n            }\n            // onsole.log(`%c[ServerProxy] after updates, movingWindow has ${viewport.dataWindow.internalData.length} records`,'color:brown')\n          }\n\n          this.processUpdates(firstBatchTimestamp);\n        }\n        break;\n\n      case Message.CHANGE_VP_RANGE_SUCCESS:\n        {\n          const viewport = this.viewports.get(body.viewPortId);\n          if (viewport) {\n            const { from, to } = body;\n            viewport.completeOperation(requestId, from, to);\n          }\n        }\n        break;\n\n      case Message.OPEN_TREE_SUCCESS:\n      case Message.CLOSE_TREE_SUCCESS:\n        break;\n\n      case Message.CREATE_VISUAL_LINK_SUCCESS:\n        {\n          const viewport = this.viewports.get(body.childVpId);\n          const parentViewport = this.viewports.get(body.parentVpId);\n          if (viewport && parentViewport) {\n            const { childColumnName, parentColumnName } = body;\n            const response = viewport.completeOperation(\n              requestId,\n              childColumnName,\n              parentViewport.clientViewportId,\n              parentColumnName\n            );\n            if (response) {\n              this.postMessageToClient(response);\n            }\n          }\n        }\n        break;\n\n      case Message.TABLE_LIST_RESP:\n        this.postMessageToClient({\n          type: Message.TABLE_LIST_RESP,\n          tables: body.tables,\n          requestId\n        } as VuuUIMessageInTableList);\n        break;\n\n      case Message.TABLE_META_RESP:\n        this.postMessageToClient({\n          type: Message.TABLE_META_RESP,\n          table: body.table,\n          columns: body.columns,\n          dataTypes: body.dataTypes,\n          requestId\n        } as VuuUIMessageInTableMeta);\n        break;\n\n      /*\n\n  private createLink(viewport: Viewport, message: VuuUIMessageOutCreateLink) {\n    const { parentVpId, parentColumnName, childColumnName } = message;\n    const requestId = nextRequestId();\n    const request = viewport.createLink(requestId, childColumnName, parentVpId, parentColumnName);\n    this.sendMessageToServer(request, requestId);\n  }\n\n        */\n      case Message.VP_VISUAL_LINKS_RESP:\n        {\n          const links = this.getActiveLinks(body.links);\n          const viewport = this.viewports.get(body.vpId);\n          if (links.length && viewport) {\n            const [clientMessage, pendingLink] = viewport.setLinks(links);\n            this.postMessageToClient(clientMessage);\n            if (pendingLink) {\n              const { colName, parentViewportId, parentColName } = pendingLink;\n              const requestId = nextRequestId();\n              const serverViewportId = this.mapClientToServerViewport.get(parentViewportId);\n              if (serverViewportId) {\n                const message = viewport.createLink(\n                  requestId,\n                  colName,\n                  serverViewportId,\n                  parentColName\n                );\n                this.sendMessageToServer(message, requestId);\n              }\n            }\n          }\n        }\n        break;\n\n      case Message.VIEW_PORT_MENUS_RESP:\n        if (body.menu.name) {\n          const viewport = this.viewports.get(body.vpId);\n          if (viewport) {\n            const clientMessage = viewport.setMenu(body.menu);\n            this.postMessageToClient(clientMessage);\n          }\n        }\n        break;\n\n      case Message.VIEW_PORT_MENU_RESP:\n        {\n          const { action } = body;\n          this.postMessageToClient({\n            type: Message.VIEW_PORT_MENU_RESP,\n            action,\n            tableAlreadyOpen: this.isTableOpen(action.table),\n            requestId\n          });\n        }\n        break;\n\n      case Message.RPC_RESP:\n        {\n          const { method, result } = body;\n          // check to see if the orderEntry is already open on the page\n          this.postMessageToClient({\n            type: Message.RPC_RESP,\n            method,\n            result,\n            requestId\n          });\n        }\n        break;\n\n      case 'ERROR':\n        console.error(body.msg);\n        break;\n\n      default:\n        console.log(`handleMessageFromServer ${(body as any).type as string}.`);\n    }\n  }\n\n  isTableOpen(table?: VuuTable) {\n    if (table) {\n      const tableName = table.table;\n      for (let viewport of this.viewports.values()) {\n        if (!viewport.suspended && viewport.table.table === tableName) {\n          return true;\n        }\n      }\n    }\n  }\n\n  // Eliminate links to suspended viewports\n  getActiveLinks(links: VuuLink[]) {\n    return links.filter((link) => {\n      const viewport = this.viewports.get(link.parentVpId);\n      return viewport && !viewport.suspended;\n    });\n  }\n\n  processUpdates(timeStamp: number) {\n    let clientMessage: VuuUIMessageInViewportUpdates;\n    this.viewports.forEach((viewport) => {\n      if (viewport.hasUpdatesToProcess) {\n        const rows = viewport.getClientRows(timeStamp);\n        const size = viewport.getNewRowCount();\n        if (size !== undefined || (rows && rows.length > 0)) {\n          clientMessage = clientMessage || {\n            type: 'viewport-updates',\n            viewports: {}\n          };\n          clientMessage.viewports[viewport.clientViewportId] = { rows, size };\n        }\n      }\n      if (clientMessage) {\n        // const now = performance.now();\n        // if (updateTime){\n        //   onsole.log(`time between updates ${now - updateTime}`)\n        // }\n        // updateTime = now;\n        // Object.values(clientMessage.viewports).forEach(({rows, size}) =>\n        //   onsole.log(`%c[ServerProxy] processUpdates, posting ${rows.length} rows (size ${size})`,'color:brown')\n        // )\n        this.postMessageToClient(clientMessage);\n      }\n    });\n  }\n}\n", "import { connect as connectWebsocket } from '@vuu-ui/data-remote/src/websocket-connection';\nimport { ServerProxy } from '@vuu-ui/data-remote/src/server-proxy/server-proxy';\nimport {\n  ConnectionStatusMessage,\n  isConnectionStatusMessage,\n  VuuUIMessageOut\n} from '@vuu-ui/data-remote/src/vuuUIMessageTypes';\n\nlet server: ServerProxy;\n\nasync function connectToServer(\n  url: string,\n  token: string,\n  onConnectionStatusChange: (msg: ConnectionStatusMessage) => void\n) {\n  const connection = await connectWebsocket(\n    url,\n    // if this was called during connect, we would get a ReferenceError, but it will\n    // never be called until subscriptions have been made, so this is safe.\n    //TODO do we need to listen in to the connection messages here so we can lock back in, in the event of a reconnenct ?\n    (msg) =>\n      isConnectionStatusMessage(msg)\n        ? onConnectionStatusChange(msg)\n        : server.handleMessageFromServer(msg)\n  );\n\n  server = new ServerProxy(connection, (msg) => sendMessageToClient(msg));\n  if (connection.requiresLogin) {\n    await server.login(token);\n  }\n}\n\nlet lastTime = 0;\nconst timings = [];\n\nfunction sendMessageToClient(message: any) {\n  const now = Math.round(performance.now());\n  if (lastTime) {\n    timings.push(now - lastTime);\n\n    // if (timings.length % 100 === 0){\n    //   console.log(timings.join(', : '))\n    //   timings.length = 0;\n    // }\n  }\n  postMessage(message);\n  lastTime = now;\n}\n\nconst handleMessageFromClient = async ({ data: message }: MessageEvent<VuuUIMessageOut>) => {\n  switch (message.type) {\n    case 'connect':\n      await connectToServer(message.url, message.token, postMessage);\n      postMessage({ type: 'connected' });\n      break;\n    case 'subscribe':\n      server.subscribe(message);\n      break;\n    case 'unsubscribe':\n      server.unsubscribe(message.viewport);\n      break;\n    // TEST DATA COLLECTION\n    // case 'send-websocket-data':\n    //   postMessage({ type: 'websocket-data', data: getTestMessages() });\n    //   break;\n    default:\n      server.handleMessageFromClient(message);\n  }\n};\n\n/* eslint-disable-next-line no-restricted-globals */\nself.addEventListener('message', handleMessageFromClient);\n\npostMessage({ type: 'ready' });\n"],
  "mappings": "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",
  "names": ["EMPTY_ARRAY", "EMPTY_ARRAY", "msgType", "viewport", "requestId", "message"]
}
