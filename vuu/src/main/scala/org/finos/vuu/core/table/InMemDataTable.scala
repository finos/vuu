package org.finos.vuu.core.table

import com.typesafe.scalalogging.StrictLogging
import org.finos.toolbox.collection.array.ImmutableArray
import org.finos.toolbox.jmx.MetricsProvider
import org.finos.toolbox.text.AsciiUtil
import org.finos.toolbox.time.Clock
import org.finos.vuu.api.TableDef
import org.finos.vuu.core.index.{HashMapIndexedStringField, IndexedField, SkipListIndexedBooleanField, SkipListIndexedCharField, SkipListIndexedDoubleField, SkipListIndexedEpochTimestampField, SkipListIndexedIntField, SkipListIndexedLongField}
import org.finos.vuu.core.row.{InMemMapRowBuilder, RowBuilder}
import org.finos.vuu.core.table.datatype.EpochTimestamp
import org.finos.vuu.core.table.{RowData, RowWithData, EmptyRowData}
import org.finos.vuu.feature.inmem.InMemTablePrimaryKeys
import org.finos.vuu.provider.{JoinTableProvider, Provider}
import org.finos.vuu.viewport.{RowProcessor, RowSource, ViewPortColumns}

import java.util
import java.util.concurrent.ConcurrentHashMap
import scala.jdk.CollectionConverters.MapHasAsScala

case class InMemDataTableData(data: ConcurrentHashMap[String, RowData], private val primaryKeyValuesInternal: TablePrimaryKeys)(implicit timeProvider: Clock) extends TableData {

  def primaryKeyValues: TablePrimaryKeys = this.primaryKeyValuesInternal

  override def setKeyAt(index: Int, key: String): Unit = {
    primaryKeyValues.set(index, key)
  }

  def dataByKey(key: String): RowData = data.get(key)

  //protected def merge(update: RowUpdate, data: RowData): RowData = MergeFunctions.mergeLeftToRight(update, data)

  protected def merge(update: RowData, data: RowData): RowData =
    MergeFunctions.mergeLeftToRight(update, data)

  def update(key: String, update: RowData): (TableData, RowData) = {

    val table = data.synchronized {
      val now = EpochTimestamp(timeProvider)
      data.getOrDefault(key, EmptyRowData) match {
        case row: RowWithData =>
          val mergedData = merge(update, row)
          val newRowData = mergedData.set(DefaultColumn.LastUpdatedTime.name, now)
          data.put(key, newRowData)
          (InMemDataTableData(data, primaryKeyValues), newRowData)
        case EmptyRowData =>
          var newRowData = update.set(DefaultColumn.CreatedTime.name, now)
          newRowData = newRowData.set(DefaultColumn.LastUpdatedTime.name, now)
          data.put(key, newRowData)
          (InMemDataTableData(data, primaryKeyValues + key), newRowData)
      }

    }

    table
  }

  def delete(key: String): TableData = {

    data.synchronized {

      data.remove(key)

      InMemDataTableData(data, primaryKeyValues.-(key))
    }
  }

  def deleteAll(): InMemDataTableData = {
    data.synchronized {
      data.clear()
      InMemDataTableData(data, InMemTablePrimaryKeys(ImmutableArray.empty))
    }
  }

}

class InMemDataTable(val tableDef: TableDef, val joinProvider: JoinTableProvider)(implicit val metrics: MetricsProvider, timeProvider: Clock) extends DataTable with KeyedObservableHelper[RowKeyUpdate] with StrictLogging {

  private final val indices = tableDef.indices.indices
    .map(index => tableDef.columnForName(index.column))
    .map(c => c -> buildIndexForColumn(c)).toMap[Column, IndexedField[_]]

  private final val columnValueProvider = InMemColumnValueProvider(this)

  override def newRow(key: String): RowBuilder = {
    new InMemMapRowBuilder().setKey(key)
  }

  override def rowBuilder: RowBuilder = new InMemMapRowBuilder

  private def buildIndexForColumn(c: Column): IndexedField[_] = {
    c.dataType match {
      case DataType.StringDataType =>
        new HashMapIndexedStringField(c)
      case DataType.IntegerDataType =>
        new SkipListIndexedIntField(c)
      case DataType.LongDataType =>
        new SkipListIndexedLongField(c)
      case DataType.DoubleDataType =>
        new SkipListIndexedDoubleField(c)
      case DataType.BooleanDataType =>
        new SkipListIndexedBooleanField(c)
      case DataType.EpochTimestampType =>
        new SkipListIndexedEpochTimestampField(c)
      case DataType.CharDataType =>
        new SkipListIndexedCharField(c)
      case _ =>
        throw new RuntimeException(s"Unsupported type ${c.dataType} in column ${c.name}")
    }
  }

  def plusName(s: String): String = name + "." + s

  override protected def createDataTableData(): TableData = {
    InMemDataTableData(new ConcurrentHashMap[String, RowData](), InMemTablePrimaryKeys(ImmutableArray.empty))
  }

  override def toString: String = s"InMemDataTable($name, rows=${this.primaryKeys.length})"

  private val eventIntoJoiner = metrics.counter(plusName("JoinTableProviderImpl.eventIntoJoiner.count"))

  private val onUpdateMeter = metrics.meter(plusName("processUpdates.Meter"))

  private val onDeleteMeter = metrics.meter(plusName("processDeletes.Meter"))

  private val onUpdateCounter = metrics.counter(plusName("processUpdates.Counter"))

  override def name: String = tableDef.name

  override def linkableName: String = name

  override def getTableDef: TableDef = tableDef

  override def indexForColumn(column: Column): Option[IndexedField[_]] = {
    indices.get(column)
  }

  override def primaryKeys: TablePrimaryKeys = data.primaryKeyValues

  @volatile protected var data: TableData = createDataTableData()

  @volatile private var updateCounterInternal: Long = 0

  override def updateCounter: Long = updateCounterInternal

  override def incrementUpdateCounter(): Unit = updateCounterInternal += 1

  override def pullRow(key: String): RowData = {
    data.dataByKey(key) match {
      case null =>
        EmptyRowData
      case row =>
        row
    }
  }

  override def pullRow(key: String, columns: ViewPortColumns): RowData = {
    data.dataByKey(key) match {
      case null =>
        EmptyRowData
      case row =>
        //row
        //CJS Check perf of this
        columns.pullRow(key, row)
    }
  }

  override def pullRowFiltered(key: String, columns: ViewPortColumns): RowData = {
    data.dataByKey(key) match {
      case null =>
        EmptyRowData
      case row =>
        //row
        //CJS Check perf of this
        columns.pullRowAlwaysFilter(key, row)
    }
  }

  override def pullRowAsArray(key: String, columns: ViewPortColumns): Array[Any] = {
    data.dataByKey(key) match {
      case EmptyRowData =>
        Array[Any]()
      case null =>
        Array[Any]()
      case row: RowWithData =>
        row.toArray(columns.getColumns)
    }
  }

  override def readRow(key: String, columns: List[String], rowProcessor: RowProcessor): Unit = {

    data.dataByKey(key) match {
      case null => rowProcessor.missingRow()
      case row =>
        columns.foreach(f => {
          val column = tableDef.columnForName(f)
          sendColumnToProcessor(key, column, row.get(column), rowProcessor)
        })

    }

  }

  private def sendColumnToProcessor(key: String, column: Column, value: Any, rowProcessor: RowProcessor): Unit = {
    rowProcessor.processColumn(column, value)
  }

  def columns(): Array[Column] = tableDef.getColumns

  lazy val viewPortColumns: ViewPortColumns = ViewPortColumnCreator.create(this, tableDef.getColumns.map(_.name).toList)

  private def updateIndices(rowkey: String, rowUpdate: RowData): Unit = {
    this.indices.foreach(colTup => {
      val column = colTup._1
      val index = colTup._2

      rowUpdate.get(column) match {
        case null =>
        case x: Any =>
          column.dataType match {
            case DataType.StringDataType =>
              index.asInstanceOf[IndexedField[String]].insert(x.asInstanceOf[String], rowkey)
            case DataType.IntegerDataType =>
              index.asInstanceOf[IndexedField[Int]].insert(x.asInstanceOf[Int], rowkey)
            case DataType.LongDataType =>
              index.asInstanceOf[IndexedField[Long]].insert(x.asInstanceOf[Long], rowkey)
            case DataType.DoubleDataType =>
              index.asInstanceOf[IndexedField[Double]].insert(x.asInstanceOf[Double], rowkey)
            case DataType.BooleanDataType =>
              index.asInstanceOf[IndexedField[Boolean]].insert(x.asInstanceOf[Boolean], rowkey)
            case DataType.EpochTimestampType =>
              index.asInstanceOf[IndexedField[EpochTimestamp]].insert(x.asInstanceOf[EpochTimestamp], rowkey)
            case DataType.CharDataType =>
              index.asInstanceOf[IndexedField[Char]].insert(x.asInstanceOf[Char], rowkey)
          }
      }
    })
  }

  private def removeFromIndices(rowkey: String, rowDeleted: RowWithData): Unit = {
    this.indices.foreach(colTup => {
      val column = colTup._1
      val index = colTup._2

      rowDeleted.get(column) match {
        case null =>
        case x: Any =>
          column.dataType match {
            case DataType.StringDataType =>
              index.asInstanceOf[IndexedField[String]].remove(x.asInstanceOf[String], rowkey)
            case DataType.IntegerDataType =>
              index.asInstanceOf[IndexedField[Int]].remove(x.asInstanceOf[Int], rowkey)
            case DataType.LongDataType =>
              index.asInstanceOf[IndexedField[Long]].remove(x.asInstanceOf[Long], rowkey)
            case DataType.DoubleDataType =>
              index.asInstanceOf[IndexedField[Double]].remove(x.asInstanceOf[Double], rowkey)
            case DataType.BooleanDataType =>
              index.asInstanceOf[IndexedField[Boolean]].remove(x.asInstanceOf[Boolean], rowkey)
            case DataType.EpochTimestampType =>
              index.asInstanceOf[IndexedField[EpochTimestamp]].remove(x.asInstanceOf[EpochTimestamp], rowkey)
            case DataType.CharDataType =>
              index.asInstanceOf[IndexedField[Char]].remove(x.asInstanceOf[Char], rowkey)
          }
      }
    })
  }

  def update(rowkey: String, rowUpdate: RowData): Unit = {
    val updatedData = data.update(rowkey, rowUpdate)
    data = updatedData._1
    updateIndices(rowkey, updatedData._2)
  }

  def delete(rowKey: String): RowData = {
    data.dataByKey(rowKey) match {
      case x: RowWithData =>
        removeFromIndices(rowKey, x)
        data = data.delete(rowKey)
        x
      case _ =>
        logger.trace(s"Got a delete for key $rowKey, but it has no row data")
        EmptyRowData
    }
  }

  def notifyListeners(rowKey: String, isDelete: Boolean = false): Unit = {
    getObserversByKey(rowKey).foreach(obs => {
      obs.onUpdate(RowKeyUpdate(rowKey, this, isDelete))
    })
  }

  private def toEvent(rowKey: String, rowData: RowData): java.util.HashMap[String, Any] = {

    val ev = new util.HashMap[String, Any]()

    this.tableDef.joinFields.foreach(field => {
      val column = this.tableDef.columnForName(field)
      ev.put(column.name, rowData.get(column))
    }
    )

    //always add this primary key
    val pk = this.tableDef.columnForName(this.tableDef.keyField)
    ev.put(pk.name, rowData.get(pk))

    ev
  }

  private def toDeleteEvent(rowKey: String, rowData: RowData): java.util.HashMap[String, Any] = {

    val ev = new util.HashMap[String, Any]()

    this.tableDef.joinFields.foreach(field => {
      val column = this.tableDef.columnForName(field)
      ev.put(column.name, rowData.get(column))
    }
    )

    //always add this primary key
    val pk = this.tableDef.columnForName(this.tableDef.keyField)
    ev.put(pk.name, rowData.get(pk))
    ev.put("_isDeleted", true)

    ev
  }

  def sendToJoinSink(rowKey: String, rowData: RowData): Unit = {
    eventIntoJoiner.inc()
    if (joinProvider.hasJoins(this.tableDef.name)) {
      val event = toEvent(rowKey, rowData)
      joinProvider.sendEvent(this.tableDef.name, event)
    }
  }

  def sendDeleteToJoinSink(rowKey: String, rowData: RowData): Unit = {
    eventIntoJoiner.inc()
    if (joinProvider.hasJoins(this.tableDef.name)) {
      val event = toDeleteEvent(rowKey, rowData)
      joinProvider.sendEvent(this.tableDef.name, event)
    }
  }

  def processUpdate(rowKey: String, rowData: RowData): Unit = {

    onUpdateMeter.mark()

    onUpdateCounter.inc()

    update(rowKey, rowData)

    sendToJoinSink(rowKey, rowData)

    notifyListeners(rowKey)

    incrementUpdateCounter()
  }

  def processDelete(rowKey: String): Unit = {

    onDeleteMeter.mark()

    onUpdateCounter.inc()

    val rowData = delete(rowKey)

    rowData match {
      case RowWithData(_, _) =>
        sendDeleteToJoinSink(rowKey, rowData)
        notifyListeners(rowKey, isDelete = true)

      case EmptyRowData =>
    }

    incrementUpdateCounter()
  }

  override def getColumnValueProvider: ColumnValueProvider = columnValueProvider
}
